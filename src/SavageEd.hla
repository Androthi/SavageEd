program SavageEd;


	#includeonce("hide\hidelib.hhf" )
	#includeonce("w.hhf")
	#includeonce("hide\hidelib.hhf")
	#includeonce("stdlib.hhf")
	#includeonce("hide\dbgwin.hhf")
	#includeonce("w32\shell32.hhf" )
	#includeonce("hide\aeslib.hhf" )

	?@nodisplay :=true;
	?@nostackalign := true;

readonly

	version			:string := "SavageEd v0.5.3";

proc
	
	// forward declarations
	
	updateStatus :procedure; @forward;
	WndProc :procedure( lparam:dword; wparam:dword; umsg:uns32; hwin:dword ); @forward;
	Msg_Command :procedure( hwin:dword; wparam:dword; lparam:dword ); @forward;
	loadFile :procedure( filename:string ); @forward;
	updateRecentLog :procedure; @forward;
	getInfo :procedure; @forward;
	
/*				notes

	explore using w.RegisterHotKey( hwnd, ID, modifier, vk )
	
	where modifier = 
		MOD_ALT
		MOD_CONTROL
		MOD_KEYUP
		MOD_SHIFT
		MOD_WIN
	
	// how to send a keyboard message
	// note, if modifier keys are pressed, this will take that
	// into account.	
	w.PostMessage( hred, w.WM_KEYDOWN, w.VK_UP, 0);

*/
	
type
	// Message and dispatch table related definitions:
		  
	MsgProc_t:	procedure( hwnd:dword; wParam:dword; lParam:dword );
	
	MsgProcPtr_t:
		record
			MessageValue	:dword;
			MessageHndlr	:MsgProc_t;			
		endrecord;

	wnd_settings:
		record
			xPos	:uns32;	// window x position
			yPos	:uns32; // window y position
			width	:uns32; // window width
			height	:uns32; // window height
			
		endrecord;
	
	LineInfo:
		record
			number	:uns32;
			index	:uns32;
			length	:uns32;
		endrecord;
	
	EditInfo:
		record
			
			// text and background colors
			textColor	:w.COLORREF;
			backColor	:w.COLORREF;
			
			// selection
			cursor		:w.CHARRANGE;
			
			// column of cursor
			charIndex	:uns32;
			
			// line info of cursor, has number, index and length
			line		:LineInfo;
			
			// if mark is set, this contains the index
			markIndex	:uns32;
			is_marked	:boolean;
			ins_ovr		:boolean;
		endrecord;
			
	findMode:
		record
			down		:boolean;
			wholeword	:boolean;
			matchcase	:boolean;
			matchpattern:boolean;
		endrecord;

	menu_items :enum {
		IDM_NEW,
		IDM_OPEN,
		IDM_INST,
		IDM_SAVE,
		IDM_SAVEAS,
		IDM_RECENT,  
		IDM_PAGESETUP,
		IDM_QUIT,
		IDM_UNDO,
		IDM_REDO,
		IDM_CUT, 
		IDM_COPY,
		IDM_PASTE,    
		IDM_SELECTALL, 
		IDM_FIND,
		IDM_FINDNEXT, 
		IDM_FINDPREV,
		IDM_REPLACE,
		IDM_EDIT_GOTO,
		IDM_TIME,
		IDM_FONT,
		IDM_BACKGROUND, 
		IDM_AUTO,
		IDM_WRAP,
		IDM_PEG,       
		IDM_READONLY,
		IDM_SETTAB,
		IDM_AUTOINDENT,
		IDM_RECENTNEW,
		IDM_CLEAREXIT,
		IDM_OPENRECENT,
		IDM_REMEMBERPOS,
		IDM_OPTIONS_ENCRYPTAES,
		IDM_OPTIONS_DECRYPTAES,
		IDM_VIEW_STATUS,
		IDM_ABOUT,
		IDM_DOCUMENTS
	};

	rect_t:
	record
		union
			left	:uns32;
			x		:uns32;
		endunion;
		union
			top		:uns32;
			y		:uns32;
		endunion;
		union
			right	:uns32;
			width	:uns32;
		endunion;
		union
			bottom	:uns32;
			height	:uns32;
		endunion;
	endrecord;


const
	ID_JAKAL				:= 1000;
	ID_FINDDLG              := 2000;
	IDC_FINDTEXT            := 2001;
	IDC_REPLACETEXT         := 2002;
	IDC_BTN_REPLACE         := 2007;
	IDC_BTN_REPLACEALL      := 2008;
	IDC_CHK_MATCHCASE       := 2003;
	IDC_CHK_WHOLEWORD       := 2004;
	IDC_RBN_UP              := 2006;
	IDC_RBN_DOWN            := 2005;
	IDC_CHK_PATTERN         := 2009;
	ID_ABOUT                := 6000;
	ID_ABOUTGRP             := 1001;
	ID_INPUT                := 3000;
	IDC_EDT_INPUT           := 3001;

	RECENT_MENU_START	:= 9000;
	RECENT_MENU_END		:= 9019;	// 10 items in recent menu
	IDC_SBAR			:= 9020;
	statusht_c			:= 21;		// height of status bar

	STATUS_PARTS		:= 4;
	POS_LINES			:=170;
	POS_INS				:=POS_LINES+35;
	POS_READONLY		:=POS_INS+18;
	POS_MARK			:=POS_READONLY+18;


	color_white :w.COLORREF := $00FF_FFFF;
	color_black :w.COLORREF := $0000_0000;
	
	szLINEBUFFER	:= 3000;	
	

readonly

	// this is the main configuration file name
	config_file		:string := "SavageEd.ini";
	
	// this is the section header in the file
	// under which to save window settings
	s_window 	:string := "Window";
	
	ClassName	:string:="SavageEDClass";
	AppName		:string:="SavageEd";
	
	RichEditDLL		:string :="riched20.dll";
//>	RichEditDLL		:string :="Msftedit.dll";
	
	// strings and error messages
	s_recent	:string := "Recent Files";
	s_settings	:string := "Settings";
	s_tabs		:string := "Tabs";
	s_font		:string := "Font";
	s_find		:string := "Find";
	s_text		:string := "Text";
	s_background_color	:string := "Background Color";
	s_text_color		:string := "Text Color";
	s_custcolors:string := "Custom Colors";
	s_openrecent:string := "Open Recent";
	s_rememberpos :string := "Remember Position";
	s_wrap		:string := "Word Wrap";
	s_autosave	:string := "Auto Save";
	s_autoindent:string := "Auto Indent";
	s_topwindow	:string := "Top Window";
	s_status	:string := "status";
	s_clearexit	:string := "Clear On Exit";
	s_recentnew	:string := "New Recent Window";
	s_readonly	:string := "Read Only";
	s_resedClass:string := "RichEdit20A";
//>	s_resedClass:string := "RICHEDIT50W";
	s_untitled	:string := "Untitled";
	s_txtext	:string := ".txt";
	s_fontname	:string := "Courier New";
	s_nl		:string := nl;
	s_insert	:string := "INS";
	s_overwrite	:string := "OVR";
	s_r			:string := "R";
	s_b			:string := " ";
	s_mark		:string := "M";
	s_empty		:string := "";
	s_inputlinen:string := "Enter Line Number";
	s_inputpwd	:string := "Enter a password upto 32 characters";
	s_inputtab	:string := "Enter tab spacing in number of characters";
	s_encext	:string := ".enc";
	s_enc		:string := "enc";
	
	s_document		:string := "SavageEd.md";	
	s_missingDLL	:string := "Could not open Riched20.dll";
	s_missingDocs	:string := "Missing Documents: SavageEd.md";
	s_nosave		:string := "Could Not Save File";
	s_noopen		:string := "Unable to open file";
	s_notemp		:string := "Unable to create temporary file";
	s_savechanges	:string := "Save changes to ";
	s_savetitle		:string := "Save As: End filename with a period (.) for no extension";
	
	curdir			:byte := '.';	// '.' = curdir

storage
	logfont			:w.LOGFONT;
	hred			:dword;			// RichEd window handle
	hinst			:dword;
	hsubmenu		:dword;	
	hwnd			:dword;			// Handle to our window.
	hmenu			:dword;
	hcontextmenu	:dword;	
	hredDLL			:dword;			// RichEd DLL handle
	hstatus			:dword;			// status bar handle

	hfont			:dword;			// font handle
	hFind			:dword;			// find dialog handle
	hFindEdt		:dword;			// handle for find edit control
	hAbout			:dword;			// About dialog handle
	frflags			:dword;
	hfile			:dword;			// file handle
	lpcbData		:dword;
	buffer			:byte[szLINEBUFFER];
	findbuf			:byte[300];
	replacebuf		:byte[300];
	ft				:w.FINDTEXTEX;
	fres			:dword;
	return			:string;	// returned from Proc_Input, caller must free string

	edstyle		:dword;
	cc			:w.CHOOSECOLOR;
	ofn			:w.OPENFILENAME;
	systime		:w.SYSTEMTIME;
	cf			:w.CHOOSEFONT;
	customColors:dword[16];
		
	editstream	:w.EDITSTREAM;
	chrg		:w.CHARRANGE;
	tr			:w.TEXTRANGE;
	wc			:w.WNDCLASSEX;	// Our "window class" data.
	msg			:w.MSG;			// Windows messages go here.
	tabs		:uns32;
	
	config		:tConfig;
	settings	:wnd_settings;
	align(4);

static
	Align(4);
	fr			:dword := 1;
	info		:EditInfo;
	queryLine	:LineInfo;
	want_pos	:uns32 := 0;	// want to keep cursor in this column
	set_mark	:uns32 := 0;
	findOpts	:findMode := findMode:[ true, false, false, false ];
	filepath	:str.strvar( w.MAX_PATH );	// store full file path
	statusParts	:int32[STATUS_PARTS]:=[POS_LINES, POS_INS, POS_READONLY, POS_MARK];
	strbuf		:str.strvar( w.MAX_PATH );
	
readonly

	// main window message table
//bm=window_commands	
	message_table	:MsgProcPtr_t; @nostorage;
		MsgProcPtr_t	
			MsgProcPtr_t:[ w.WM_COMMAND,	&Msg_Command	],
			MsgProcPtr_t:[ w.WM_DESTROY,	&Msg_Destroy	],
			MsgProcPtr_t:[ w.WM_CLOSE,		&Msg_Close		],
			MsgProcPtr_t:[ w.WM_CREATE,		&Msg_Create		],
			MsgProcPtr_t:[ w.WM_SIZE,		&Msg_Size		],
			MsgProcPtr_t:[ w.WM_CONTEXTMENU,&Msg_Context	],
			MsgProcPtr_t:[ w.WM_SETFOCUS,	&Msg_SetFocus	],
			MsgProcPtr_t:[ w.WM_DROPFILES,  &openDroppedFile],
			MsgProcPtr_t:[ w.WM_NOTIFY,		&Msg_Notify],

			// add more messages here
			MsgProcPtr_t:[ 0, NULL ];	// This marks the end of the list.

	// WM_COMMAND message table, wparam items go here
	command_table	:MsgProcPtr_t; @nostorage;
		MsgProcPtr_t
			MsgProcPtr_t:[ IDM_QUIT,	&Cmd_File_Quit	],

			// add more commands here
			MsgProcPtr_t:[ 0,				NULL			];
		

proc

	Error :procedure( error_msg:string );
	begin Error;
	
		w.MessageBox(NULL,error_msg,"ERROR",w.MB_OK | w.MB_ICONERROR );
		
		cmp(hwnd,0);
		je _nowindow;
		w.PostQuitMessage(0);
		exit Error;
		
	_nowindow:
		xor(eax,eax);
	
	end Error;

	selectAll :procedure {@noframe};
	begin selectAll;
		
		mov	(0, chrg.cpMin);
		mov	(-1,chrg.cpMax);
		w.SendMessage(hred,w.EM_EXSETSEL,0,&chrg);
		ret();
		
	end selectAll;

	
	getTempName :procedure( prefix:string; ext:string; dest:string );
	
		// gets a temp name based on current directory
		// format:
		// curdir\prefixxxxxxxxxext
	
	begin getTempName;
		
		// doubt there will ever be a similar result, but just in case...
		forever
			w.GetTickCount();
			conv.u32ToStr( eax, 20, ' ', hide.strbuf );
			str.trim( hide.strbuf );
			filesys.gwd( dest );
			str.put2( dest, chars.dir_sep, prefix, hide.strbuf, ext );
			
			breakif( ! filesys.exists( dest ) );
		endfor;
		
	end getTempName;

	
	warning :procedure ( warning_msg:string );
	begin warning;
		
		w.MessageBox( NULL, warning_msg, "Warning", w.MB_OK | w.MB_ICONWARNING );

	end warning;


	Msg_SetFocus :procedure( hwin:dword; wparam:dword; lparam:dword );
	begin Msg_SetFocus;
		
		w.SetFocus( hred );
		xor( eax, eax );
		
	end Msg_SetFocus;

	
	Msg_Size :procedure( hwin:dword; wparam:dword; lparam:dword );
		
		var
			rect	:w.RECT;
			height	:dword;

	begin Msg_Size;
		
		w.GetClientRect( hwnd, rect );
		mov( rect.bottom, eax );
		sub( rect.top, eax );
		mov( eax, height );
		
		if( config.readBool( s_window, s_status ) ) then
		
			sub( statusht_c, height );
			w.SendMessage( hstatus, w.WM_SIZE, 0, 0 );

		endif;
		w.MoveWindow( hred, 0, rect.top, rect.right, height, true );
		
		xor( eax, eax );
		
	end Msg_Size;
	
	updateTitle: procedure {@noframe};
	begin updateTitle;
		if (w.SendMessage(hred, w.EM_GETMODIFY,0,0)) then
			filesys.extractFilename( filepath, hide.strbuf );
			str.insert("*",0, hide.strbuf);
			w.SetWindowText( hwnd, hide.strbuf );
		endif;
		ret();
	end updateTitle;

	
	setWindowTitle :procedure {@noframe};
	begin setWindowTitle;
		
		filesys.extractFilename( filepath, hide.strbuf );
		if(hred) then
			if (w.SendMessage(hred, w.EM_GETMODIFY,0,0)) then
				str.insert("*",0, hide.strbuf);
			endif;
		endif;
		w.SetWindowText( hwnd, hide.strbuf );
		ret();

	end setWindowTitle;
	
	StreamInProc :procedure( var pBytesRead:dword ; NumBytes:dword ; var pbuffer:dword ; _hFile:dword );	
	begin StreamInProc;
		
		w.ReadFile( _hFile, pbuffer, NumBytes, pBytesRead, NULL );
		xor	(1, eax);
	
	end StreamInProc;

	StreamOutProc :procedure( var pBytesRead:dword ; NumBytes:dword ; var pbuffer:dword ; _hFile:dword );
	begin StreamOutProc;
		
		w.WriteFile( _hFile, pbuffer, NumBytes, pBytesRead, NULL );
		xor	(1, eax);

	end StreamOutProc;

	saveFile :procedure( filename:string );
	begin saveFile;
		
		filesys.extractExt( filename, strbuf );		
		if( str.ieq( strbuf, s_enc ) ) then
			warning( "can't save encrypted files" );
			jmp done;
		endif;
		
		try
			fileio.openNew( filename );
			mov( eax,hfile );
			mov( eax, editstream.dwCookie );
			mov( &StreamOutProc, editstream.pfnCallback );
			w.SendMessage( hred, w.EM_STREAMOUT, w.SF_TEXT, &editstream );
			fileio.close( hfile );
			w.SendMessage(hred, w.EM_SETMODIFY, false, 0);
			mov( false,eax );
			
		anyexception
			
			warning( s_nosave );
			mov( true, eax );
			
		endtry;
		push( eax );
		updateRecentLog();
		updateTitle();
		pop( eax );
		done:
	end saveFile;
	
	SaveAs :procedure {@noframe};
	begin SaveAs;

		w.RtlZeroMemory( &ofn, @size(ofn) );
		mov( @size(ofn), ofn.lStructSize );
		mov( hwnd, ofn.hWndOwner );
		mov( hinst, ofn.hInstance );
		mov( &curdir, eax );
		mov( eax, ofn.lpstrInitialDir );
		
		zstr.cpy( (type zstring filepath ), &buffer );
		mov( &buffer, eax );
		mov( eax, ofn.lpstrFile );
		mov( s_savetitle, eax );
		mov( eax, ofn.lpstrTitle );
		mov( @elements(buffer)-1, ofn.nMaxFile );
		mov( w.OFN_EXPLORER | w.OFN_LONGNAMES | w.OFN_OVERWRITEPROMPT, ofn.Flags );
		
		dbg.put("ofn");
		w.GetSaveFileName( ofn );
		if(eax) then
			
			str.cpyz( &buffer, filepath );
			str.rmvLastChar2( filepath, hide.strbuf );
			if( al = '.') then
				
				str.cpy( hide.strbuf, filepath );
				
			else
				
				if( ! filesys.hasExtension( filepath ) ) then
					
					str.put2( filepath, s_txtext );
					
				endif;
				
			endif;
			
			saveFile( filepath );
			if(eax) then
			 	// reset FileName to untitled
			 	str.cpy( s_untitled, filepath );

			endif; 
			
			setWindowTitle();
			xor( eax, eax );
			
		else
			
			mov(-1,eax);
			
		endif;
		ret();
	end SaveAs;

	checkSave :procedure { @noframe };
	begin checkSave;
		
		if( str.ieq( filepath, s_untitled ) ) then
			
			if( config.readBool( s_settings, s_autosave ) ) then
				
				getTempName( s_untitled, s_txtext, filepath );
				mov( 0, eax );
			else
				
				SaveAs();
				
			endif;
		else
			
			mov( 0, eax );
			
		endif;
		
		if( ! eax  ) then
			saveFile( filepath );
		endif;
		setWindowTitle();
		
		ret();
	end checkSave;
	
	// checks for modified file, gets confirmation from user
	getConfirm :procedure { @noframe, @returns("EAX") };
	begin getConfirm;
		w.SendMessage(hred, w.EM_GETMODIFY,0,0);
		if (eax) then
			
			
			if( config.readBool( s_settings, s_autosave ) ) then

				checkSave();
				mov( false, eax );
			
			else
				
				w.MessageBox(hwnd, filepath, s_savechanges, w.MB_YESNOCANCEL | w.MB_ICONQUESTION);
				if( eax=w.IDYES ) then
						
					checkSave();
					xor( eax, eax );
					
				elseif (eax=w.IDNO) then
			
					xor( eax, eax );
			
				else
			 
					mov( true, eax );
					
				endif;
				
			endif;
		else
			
			xor( eax, eax );
			
		endif;
		ret();
	end getConfirm;

	
	setFormat :procedure;
	
		var
			cf	:w.CHARFORMAT2;
			tm	:w.TEXTMETRIC;	
			
	begin setFormat;
		
		w.SendMessage(hred, w.EM_GETMODIFY,0,0);
		push( eax );
		w.SendMessage(hred, w.EM_EXLIMITTEXT,0,-1);
		
		lea (eax, cf);
		w.RtlZeroMemory (eax, @size(cf));
		mov	(@size(cf), cf.cbSize);
		mov	(w.CFM_CHARSET | w.CFM_FACE | w.CFM_SIZE | w.CFM_COLOR, cf.dwMask);
		mov	(logfont.lfCharSet, al);
		mov	(al,cf.bCharSet);
		mov	(logfont.lfPitchAndFamily, al);
		mov	(al, cf.bPitchAndFamily);
		w.lstrcpyn(cf.szFaceName,&logfont.lfFaceName,w.LF_FACESIZE);
		mov	(logfont.lfHeight, eax);
		neg	(eax);
		mov	(15,ecx);
		mul (ecx);
		mov	(eax, cf.yHeight);
		push (info.textColor);
		pop (cf.crTextColor);
		w.SendMessage( hred, w.EM_SETBKGNDCOLOR, false, info.backColor);
		w.SendMessage( hred, w.WM_SETFONT, hfont, true );
	
		
		w.GetDialogBaseUnits();
		movzx( ax, ecx );
		config.readUns( s_settings, s_tabs );
		mul( ecx );
		shr( 1, eax );
		mov( eax, tabs );
		dbg.put("tabs :", tabs );
		w.SendMessage(hred, w.EM_SETTABSTOPS, 1, &tabs );
		
		w.SendMessage( hred, w.EM_SETMARGINS, w.EC_LEFTMARGIN | w.EC_RIGHTMARGIN, 5<<16 | 5 );
		
		lea(eax, cf);
		w.SendMessage( hred, w.EM_SETCHARFORMAT, w.SCF_ALL, eax );
		pop	(eax);
		w.SendMessage( hred, w.EM_SETMODIFY, eax,0 );
		
	end setFormat;

	GetSelText :procedure( lpBuff:dword );
	begin GetSelText;
	
		mov( lpBuff, eax );
		mov( eax, tr.lpstrText );
		
		w.SendMessage(hred, w.EM_EXGETSEL,0, &tr.chrg);
		mov	(tr.chrg.cpMax,eax);
		sub	(tr.chrg.cpMin,eax);
		if( eax >= @elements( findbuf ) ) then
			mov( @elements( findbuf) -1, tr.chrg.cpMax );
		endif;
		
		w.SendMessage(hred, w.EM_GETTEXTRANGE,0,&tr);
	
	end GetSelText;
		
	AboutDlgProc :procedure( lParam:dword; wParam:dword; uMsg:uns32; hDlg:dword);
	begin AboutDlgProc;
		
		if (uMsg = w.WM_INITDIALOG) then
			mov	(hDlg, hAbout);
			w.SetDlgItemText( hAbout,ID_ABOUTGRP,version ); 
			w.SetFocus(hAbout);
			
		elseif (uMsg = w.WM_COMMAND) then
			 if (wParam = w.IDOK || wParam= w.IDCANCEL) then				

			 	w.SendMessage(hDlg, w.WM_CLOSE,NULL,NULL);

			 endif;
		elseif (uMsg = w.WM_CLOSE) then

			w.DestroyWindow(hAbout);
			mov	(0, hAbout);
			w.SetFocus(hred);
		
		else
			mov (false, eax);
			exit AboutDlgProc;
		endif;
	
		mov (true, eax);	
		
	end AboutDlgProc;
	
	getConfigPath :procedure( s:string );
	begin getConfigPath;
		
		w.GetModuleFileName (hinst, &buffer, @size(buffer) );
		str.cpyz( &buffer, s );
		filesys.extractPath( s, s );
		str.put2( s, '\', config_file ); 

		
	end getConfigPath;
		
	InsertTime :procedure { @noframe };
	begin InsertTime;
	
		w.GetSystemTime(systime);
		w.GetDateFormat(	w.LOCALE_USER_DEFAULT,
						w.LOCALE_NOUSEROVERRIDE,
						NULL,	// systemtime
						NULL,	// format
						&buffer,
						@size(buffer));
		mov( ' ', buffer[eax-1] );
		mov( #$0, buffer[eax] );
		w.SendMessage(hred, w.EM_REPLACESEL, true, &buffer);
		
		w.GetTimeFormat(	w.LOCALE_USER_DEFAULT,
						w.LOCALE_NOUSEROVERRIDE,
						NULL,
						NULL,
						&buffer,
						@size(buffer));
		w.SendMessage(hred, w.EM_REPLACESEL, true, &buffer);
		ret();
	
	end InsertTime;
		
	
	JumpLog :procedure // direction in al
		{@noframe};
	begin JumpLog;
	
		if (al='<') then	// append at top
			w.SendMessage( hred,w.EM_SETSEL,5,5 );
			
		else				// append at bottom
			w.SendMessage( hred,w.EM_SETSEL,-1,-1 );
		endif;
		w.SendMessage( hred, w.EM_REPLACESEL,true, s_nl );
		InsertTime();
		w.SendMessage( hred, w.EM_REPLACESEL,true, s_nl );
		ret();
		
	end JumpLog;
	
		// check for .LOG message on top of loaded file.
	checkLog :procedure{ @noframe };
	begin checkLog;
		//dbg.put ("CheckLog");
		mov( 0, tr.chrg.cpMin );
		mov( 5, tr.chrg.cpMax );
		mov( &buffer,tr.lpstrText );
		w.SendMessage( hred, w.EM_GETTEXTRANGE, 0, &tr);
		mov(&buffer,esi);
		lodsd();
		if ( eax = $474f4c2e ) then	// .LOG
			// check direction
			lodsb();
			JumpLog();
			w.SendMessage( hred, w.EM_SETMODIFY, false, 0 );
		endif;
		ret();
	end checkLog;

	newInstance :procedure( filename:string );
		
		var
			s	:string;
			
	
	begin newInstance;
		dbg.put("newInstance" );
		
		move( str.talloc( 300 ), s );
		add( 20, settings.xPos );
		config.writeUns( s_window, "xPos", settings.xPos );
		add( 20, settings.yPos );
		config.writeUns( s_window, "yPos", settings.yPos );
		config.writeUns( s_window, "width", settings.width);
		config.writeUns( s_window, "height", settings.height);
		
		getConfigPath( s );
		config.writeFileName( s );
		
		w.GetModuleFileName( NULL, &buffer, @size(buffer) );
		str.cpyz( &buffer, s );
		if( filename != NULL ) then
			str.put2( s, ' ', filename );
		endif;
		os.bkgnd( s );
		
	end newInstance;

	// handles Font selection
	selectFont :procedure { @noframe };
	begin selectFont;
	
		//lea(eax, cf);
		w.RtlZeroMemory( &cf, @size(cf) );
		mov( @size(cf), cf.lStructSize );
		mov( hwnd, eax );
		mov( eax, cf.hWndOwner );
		mov( &logfont, cf.lpLogFont );
		mov( w.CF_SCREENFONTS | w.CF_EFFECTS | w.CF_INITTOLOGFONTSTRUCT, cf.Flags );
		push( info.textColor );
		pop( cf.rgbColors );
		
		w._ChooseFont(cf);
		if (eax) then
		
			w.DeleteObject(hfont);
			w.CreateFontIndirect(logfont);
			mov( eax, hfont );
			push( cf.rgbColors );
			pop( info.textColor );
			setFormat();
			config.writeHex( s_text, s_background_color, info.backColor);
			config.writeHex( s_text, s_text_color, info.textColor);
			config.writeBin( s_text, s_font, &logfont, @size( logfont ) );
			
		endif;
		ret();
	end selectFont;
	
	selectColor :procedure { @noframe };
	begin selectColor;
		dbg.put ("selectColor");
		mov( &cc, eax );
		w.RtlZeroMemory( eax, @size(w.CHOOSECOLOR) );
		mov( @size (cc), eax );
		mov( eax, cc.lStructSize );
		push(hwnd );
		pop( cc.hwndOwner );
		push( hinst );
		pop( cc.hInstance );
		mov( w.CC_RGBINIT, cc.Flags );
		mov( &customColors, cc.lpCustColors);
		push( info.backColor );
		pop( cc.rgbResult );
		mov( &cc, eax );
		w._ChooseColor( &cc );
		if( eax ) then
			push( cc.rgbResult );
			pop( info.backColor );
			setFormat();
			config.writeBin( s_text, s_custcolors, &customColors, @size( customColors ) );
//			config.writeBin( s_text, s_colors, &colors, @size( colors ) );
			config.writeHex( s_text, s_background_color, info.backColor);
			config.writeHex( s_text, s_text_color, info.textColor);

		endif;
			
		ret();
	end selectColor;

	updateMenu :procedure;	
	
		var
			count	:uns32;
			
	
	begin updateMenu;
		pushabi;
		//dbg.put("updateMenu");
		if( hsubmenu <> 0 ) then
			w.DestroyMenu( hsubmenu );
			mov( 0, hsubmenu );
		endif;
			
		w.CreatePopupMenu();
		mov( eax, hsubmenu );
		mov( RECENT_MENU_START, ebx );
		config.getItemCount( s_recent );
		mov( eax, count );
		
		for( mov( 0, ecx ); ecx < count; inc( ecx ) ) do
			
			if( config.readItem( s_recent, ecx, hide.strbuf ) ) then
				USE( ECX, EBX );
				w.AppendMenu( hsubmenu, w.MF_BYPOSITION | w.MF_ENABLED | w.MF_STRING,
							ebx, hide.strbuf);
				ENDUSE;
			endif;
			inc( ebx );
		endfor;
		
		w.GetMenu( hwnd );
		w.GetSubMenu( eax, 0 );
		w.ModifyMenu( eax, 7, w.MF_BYPOSITION | w.MF_POPUP| w.MF_ENABLED,
					hsubmenu, s_recent );
		w.DrawMenuBar( hwnd );
		
		//dbg.put("/updateMenu");
		popabi;
	end updateMenu;
	
	openRecent :procedure(id:dword);
	
		var
			s	:string;
			
	begin openRecent;
		//dbg.put("openRecent" );
		move( str.talloc( 300 ), s );
		getConfirm();
		if (! eax) then
			w.GetMenu( hwnd );
			w.GetMenuStringA( eax, id, buffer, @elements( buffer ), w.MF_BYCOMMAND );
			str.cpyz( &buffer, s );
			
			if( config.readBool( s_settings, s_recentnew )) then
				
				newInstance( s );
				
			else
				
				loadFile( s );
				if( ! eax ) then
					config.findItem( s_recent, s );
					config.deleteItem( s_recent, eax );
					updateMenu();
				endif;
				
			endif;
			
		endif;
	
	end openRecent;

	updateRecentLog :procedure {@noframe};
	begin updateRecentLog;
		//dbg.put("updateRecentLog");
		if( config.findItem ( s_recent, filepath ) <> -1 ) then
			
			config.deleteItem ("Recent Files", eax);
			
		endif;
		
		config.insertItem( s_recent, 0, filepath );
		
		if( config.getItemCount( s_recent ) > 20) then
			
			config.deleteItem( s_recent, 20 );
			
		endif;
		updateMenu();
		ret();
	end updateRecentLog;

	setText :procedure( hfile:dword );
	begin setText;
		
		w.SetWindowText( hred, 0 );
		w.GetFileSize( hfile, NULL );
		if( eax > 0 ) then
			mov( hfile, editstream.dwCookie );
			mov( &StreamInProc, editstream.pfnCallback );
			w.SendMessage( hred, w.EM_STREAMIN, w.SF_TEXT, &editstream );
			w.SendMessage( hred, w.EM_SETMODIFY, false,0 );
		else
		
		endif;
	end setText;


	loadFile :procedure( filename:string );
	begin loadFile;
		dbg.put("loadFile");		
		try
			
			fileio.open( filename, fileio.r );
			mov( eax, hfile );
			setText( hfile );
			fileio.close( hfile );
			str.cpy( filename, filepath );

			dbg.put("filename = ", filename );
			filesys.extractExt( filename, strbuf );
			if( str.ieq( strbuf, s_enc ) ) then
				dbg.put("is encrypted" );
				w.EnableMenuItem( hmenu, IDM_OPTIONS_DECRYPTAES, w.MF_BYCOMMAND | w.MF_ENABLED );
				w.EnableMenuItem( hmenu, IDM_OPTIONS_ENCRYPTAES, w.MF_BYCOMMAND | w.MF_GRAYED );
			else
				dbg.put("not encrypted");
				w.EnableMenuItem( hmenu, IDM_OPTIONS_DECRYPTAES, w.MF_BYCOMMAND | w.MF_GRAYED );
				w.EnableMenuItem( hmenu, IDM_OPTIONS_ENCRYPTAES, w.MF_BYCOMMAND | w.MF_ENABLED );
			endif;

			setWindowTitle();
			checkLog();
			updateRecentLog();
			setFormat();
			setWindowTitle();		
			or( 1, eax );
			
		anyexception
			
			warning( s_noopen );
			xor( eax, eax );
			
		endtry;
		
		dbg.put("/loadFile");
	end loadFile;

	fileOpen :procedure { @noframe};
	begin fileOpen;
	
		w.RtlZeroMemory(&ofn,@size(ofn));
		mov	(@size(ofn),ofn.lStructSize);
		mov	(hwnd,ofn.hWndOwner);
		mov( hinst, ofn.hInstance );
		mov	(&curdir,eax);
		mov (eax, ofn.lpstrInitialDir);
		
		mov (0, buffer[0]);
		mov (&buffer, ofn.lpstrFile);
		mov	(@elements(buffer)-1, ofn.nMaxFile);
		
		mov	(w.OFN_PATHMUSTEXIST | w.OFN_FILEMUSTEXIST | w.OFN_LONGNAMES,ofn.Flags);
		w.GetOpenFileName(ofn);
			if (eax) then
				str.cpyz( &buffer, hide.strbuf );
				loadFile( hide.strbuf );
			endif;
		w.SetFocus(hred);
		updateStatus();
		ret();
	end fileOpen;

	// handles opening dropped files
	openDroppedFile :procedure( hwnd:dword; wParam:dword; lParam:dword );
	begin openDroppedFile;
		pushabi;
		
		w.SetForegroundWindow(hwnd);
		w.SetFocus(hred);	
	
		getConfirm();
		if (!eax) then	
			w.SetWindowText( hred, 0 );		// clear edit window
			w.DragQueryFile( wParam, 0, &buffer, @size(buffer) );
			w.GetLongPathName( &buffer, &buffer, @size(buffer) );
			str.cpyz( &buffer, hide.strbuf );
			loadFile( hide.strbuf );
			
		endif;
		popabi;
		xor( eax, eax );
		
	end openDroppedFile;	
		
	findNormal :procedure( opts:dword );
	begin findNormal;
		
		move( &findbuf, ft.lpstrText);
		dbg.put("find normal : ");
		dbg.putz( ft.lpstrText );
		w.SendMessage( hred, w.EM_FINDTEXTEX, opts, &ft );
		mov( eax, fres );
		if(eax != -1) then
	
			w.SendMessage( hred, w.EM_EXSETSEL, 0, &ft.chrgText );
			w.SendMessage( hred,w.EM_SCROLLCARET,0,0 );
	
		else

			// done search, reset and start searching from top
			// or bottom
			if( findOpts.down ) then
				w.SendMessage( hred, w.EM_SETSEL, 0, 0 );
				mov( 0, ft.chrg.cpMin );
				
			else
				w.SendMessage( hred, w.WM_GETTEXTLENGTH, 0, 0 );
				w.SendMessage( hred, w.EM_SETSEL, eax, eax );
			endif;
		endif;
		
	end findNormal;
	
	findPattern :procedure( opts:dword );
	
		var
			hmem	:hide.memory;
			
	
	begin findPattern;
		
		dbg.enters( "findPattern" );
		cmp( (type byte findbuf[0]), 0 );
		mov( 0, hmem );
		je retFalse;
		
		move( ft.chrg.cpMin, tr.chrg.cpMin );
		w.SendMessage( hred, w.WM_GETTEXTLENGTH, 0, 0 );
		mov( eax, tr.chrg.cpMax );
		sub( ft.chrg.cpMin, eax );
		
		add( 4, eax );
		mem.zalloc( eax );
		mov( eax, hmem );
		mov( eax, tr.lpstrText );
		
		w.SendMessage( hred, w.EM_GETTEXTRANGE, 0, &tr );
		mov( hmem, esi );
		str.cpyz( &findbuf, hide.strbuf );
		scan.pfind( hide.strbuf, findOpts.matchcase );
		jnc retFalse;
		
		// we found the pattern...
		// find it's index and length.  esi = start, edi = end.
		// edi - esi = length
		// esi - hmem = index into buffer
		mov( esi, eax ); 
		sub( hmem, eax );
		add( eax, ft.chrg.cpMin );
		move( ft.chrg.cpMin, fres );
		mov( edi, eax );
		sub( esi, eax );
		push( ft.chrg.cpMin );
		pop( ft.chrg.cpMax );
		add( eax, ft.chrg.cpMax );
		w.SendMessage( hred, w.EM_EXSETSEL, 0, &ft.chrg );
		w.SendMessage( hred,w.EM_SCROLLCARET,0,0 );
		
		jmp done;
		
		retFalse:
			dbg.put("not found");
			w.SendMessage( hred, w.EM_SETSEL, 0, 0 );
			mov( 0, ft.chrg.cpMin );
			mov( -1, fres );
			
			
		done:
			if( hmem > 0 ) then
				mem.free( hmem );
			endif;
			mov( fres, eax );
				
		dbg.exits( "findPattern" );		
	end findPattern;
	
	Find :procedure {@noframe};
	begin Find;
		pushabi;
		dbg.put("find");
		w.SendMessage(hred, w.EM_EXGETSEL,0, &ft.chrg);
		
		if( findOpts.down ) then
	
			mov( ft.chrg.cpMax, eax );
			if( eax != ft.chrg.cpMin ) then
				// we have a selection already, don't try to find
				// currently selected text!
				push( ft.chrg.cpMax );
				pop( ft.chrg.cpMin );
			endif;
			mov( -1, ft.chrg.cpMax );

		else

			mov( 0, ft.chrg.cpMax );

		endif;

		xor( eax, eax );
		if( findOpts.down ) then
			or( w.FR_DOWN, eax );
		endif;
		if( findOpts.matchcase ) then
			or( w.FR_MATCHCASE, eax );
		endif;
		if( findOpts.wholeword ) then
			or( w.FR_WHOLEWORD, eax );
		endif;

		if( findOpts.matchpattern ) then
			
			findPattern( eax );
			
		else
			
			findNormal( eax );
			
		endif;
		popabi;
		ret();
	end Find;

	AddMenus :procedure;
		storage
			file_menu :dword;
			edit_menu :dword;
			options_menu :dword;
			view_menu :dword;
			help_menu :dword;
			s_recent_menu :dword;
			
	begin AddMenus;
		
		// create all the menu handles here
		mov( w.CreateMenu(), file_menu);
		mov( w.CreateMenu(), edit_menu);
		mov( w.CreateMenu(), options_menu);
		mov( w.CreateMenu(), view_menu);
		mov( w.CreateMenu(), help_menu);
		mov( w.CreatePopupMenu(), s_recent_menu );
		
		//
		//	File Menu
		//
		
		w.AppendMenu( file_menu, w.MF_STRING, IDM_NEW, "&New	Ctrl+N");
		w.AppendMenu( file_menu, w.MF_STRING, IDM_OPEN, "&Open	Ctrl+O");
		w.AppendMenu( file_menu, w.MF_STRING, IDM_INST, "New &Window	Shift+Ctrl+N");
		w.AppendMenu( file_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( file_menu, w.MF_STRING, IDM_SAVE, "&Save	Ctrl+S");
		w.AppendMenu( file_menu, w.MF_STRING, IDM_SAVEAS, "Save &As	Shift+Ctrl+S");
		w.AppendMenu( file_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( file_menu, w.MF_STRING, IDM_RECENT, "Recent Files");
		w.AppendMenu( file_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( file_menu, w.MF_STRING, IDM_QUIT, "&Quit	ESC");
		w.AppendMenu( hmenu, w.MF_POPUP, file_menu, "&File");

		//
		//	Edit Menu
		//
	
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_UNDO, "&Undo	Ctrl+Z");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_REDO, "&Redo	Ctrl+Y");
		w.AppendMenu( edit_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_CUT, "&Cut	Ctrl+X");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_COPY, "C&opy	Ctrl+C");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_PASTE, "&Paste	Ctrl+V");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_SELECTALL, "Select &All	Ctrl+A");
		w.AppendMenu( edit_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_FIND, "&Find / Replace	Ctrl+F");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_FINDNEXT, "Find &Next	F3");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_FINDPREV, "Find &Previous	Ctrl+F3");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_EDIT_GOTO, "&Goto Line	Ctrl+G");
		w.AppendMenu( edit_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_TIME, "&Insert Date/Time	F5");
		w.AppendMenu( hmenu, w.MF_POPUP, edit_menu, "&Edit");

		//
		//	Options Menu
		//

		w.AppendMenu( options_menu, w.MF_STRING, IDM_FONT, "&Font...");
		w.AppendMenu( options_menu, w.MF_STRING, IDM_BACKGROUND, "&Background Color...");
		w.AppendMenu( options_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( options_menu, w.MF_STRING, IDM_AUTO, "&Autosave	F2");
		w.AppendMenu( options_menu, w.MF_STRING, IDM_READONLY, "&Read Only	F6");
		w.AppendMenu( options_menu, w.MF_STRING, IDM_SETTAB, "&Set Tabs...");
		w.AppendMenu( options_menu, w.MF_STRING, IDM_AUTOINDENT, "Auto &Indent");
		w.AppendMenu( options_menu, w.MF_STRING | w.MF_POPUP, s_recent_menu, "Recent File Options");
			w.AppendMenu( s_recent_menu, w.MF_STRING, IDM_RECENTNEW, "Open in New Window");
			w.AppendMenu( s_recent_menu, w.MF_STRING, IDM_CLEAREXIT, "Clear History on Exit");
			w.AppendMenu( s_recent_menu, w.MF_STRING, IDM_OPENRECENT, "Open Most Recent");
			w.AppendMenu( s_recent_menu, w.MF_STRING, IDM_REMEMBERPOS, "Remember Position");
		w.AppendMenu( options_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( options_menu, w.MF_STRING, IDM_OPTIONS_ENCRYPTAES, "AES &Encrypt");
		w.AppendMenu( options_menu, w.MF_STRING | w.MF_DISABLED, IDM_OPTIONS_DECRYPTAES, "AES &Decrypt");
		w.AppendMenu( hmenu, w.MF_POPUP, options_menu, "&Options");

		//
		//	View Menu
		//

		w.AppendMenu( view_menu, w.MF_STRING, IDM_PEG, "&Stay on Top	Ctrl+T");
		w.AppendMenu( view_menu, w.MF_STRING, IDM_WRAP, "&Word Wrap	F4");
		w.AppendMenu( view_menu, w.MF_STRING, IDM_VIEW_STATUS, "&Status Bar");
		w.AppendMenu( hmenu, w.MF_POPUP, view_menu, "&View");

		//
		//	Help Menu
		//

		w.AppendMenu( help_menu, w.MF_STRING, IDM_ABOUT, "&About...");
		w.AppendMenu( help_menu, w.MF_STRING, IDM_DOCUMENTS, "&Documents");
		w.AppendMenu( hmenu, w.MF_POPUP, help_menu, "&Help");

		w.SetMenu(hwnd, hmenu);

	end AddMenus;

	Proc_Input :procedure( lParam:dword; wParam:dword; uMsg:uns32; hWin:dword );
	begin Proc_Input;
		pushabi;
		
		mov( uMsg, eax );
		
		if( eax = w.WM_COMMAND ) then
	
			mov( wParam, eax );
			mov( eax, edx );
			shr( 16, edx );
			and( $0ffff, eax );
			if( edx = w.BN_CLICKED ) then
				
				if( eax = w.IDOK ) then
					
					w.GetDlgItemTextA( hWin, IDC_EDT_INPUT, buffer, @size(buffer) );
					str.a_cpyz( &buffer );
					mov( eax, return );
					
					w.SendMessage( hWin, w.WM_DESTROY, 0, 0 );
					
				elseif( eax = w.IDCANCEL ) then
					
					mov( 0, return );
					w.SendMessage( hWin, w.WM_DESTROY, 0, 0 );
					
				endif;
				
			endif;
	
		elseif( eax = w.WM_CLOSE ) then
			
			w.SendMessage( hWin, w.WM_DESTROY, 0, 0 );
		
		elseif( eax = w.WM_DESTROY ) then
			
			w.EndDialog( hWin, return );
			
		elseif( eax = w.WM_INITDIALOG ) then
			
			if( lParam ) then
				w.SetWindowText( hWin, lParam );
			endif;
			
			w.GetDlgItem( hWin, IDC_EDT_INPUT );
			w.SetFocus( eax );
			
		endif;
		
		xor( eax, eax );
		popabi;
	end Proc_Input;

	
	Proc_FindDlg :procedure( lParam:dword; wParam:dword; uMsg:uns32; hWin:dword );
	begin	Proc_FindDlg;
		pushabi;
		mov(uMsg,eax);
		if (eax = w.WM_INITDIALOG) then
			mov	(hWin, eax);
			mov	(eax,hFind);
			mov(0,fres);
			w.SendDlgItemMessage(hWin,IDC_FINDTEXT,w.EM_LIMITTEXT, @elements(findbuf)-1, 0);
			w.SendDlgItemMessage(hWin,IDC_FINDTEXT,w.WM_SETTEXT,0, &findbuf);
			
			w.SendDlgItemMessage(hWin,IDC_REPLACETEXT,w.EM_LIMITTEXT, @elements(replacebuf)-1, 0);
			w.SendDlgItemMessage(hWin,IDC_REPLACETEXT,w.WM_SETTEXT,0, &replacebuf);
			
			if( findOpts.matchcase ) then
				w.CheckDlgButton(hWin,IDC_CHK_MATCHCASE,w.BST_CHECKED);
			endif;
			
			if( findOpts.wholeword ) then
				w.CheckDlgButton(hWin,IDC_CHK_WHOLEWORD,w.BST_CHECKED);
			endif;
			
			if( findOpts.matchpattern ) then
				w.CheckDlgButton(hWin,IDC_CHK_PATTERN,w.BST_CHECKED);
			endif;
			
			if( findOpts.down ) then
				mov( IDC_RBN_DOWN, edx );
			else
				mov( IDC_RBN_UP, edx );
			endif;
			w.CheckDlgButton(hWin, edx, w.BST_CHECKED);
				
		elseif (eax = w.WM_COMMAND) then
			mov	(wParam, eax);
			mov	(eax,edx);
			shr	(16,edx);
			and	($ffff,eax);
			if (edx = w.BN_CLICKED) then
				
				if(eax = w.IDOK) then
					
					Find();
					w.SetFocus(hFind);
					
				elseif(eax = w.IDCANCEL) then
				
					w.SendMessage( hWin, w.WM_CLOSE, NULL, NULL );
					
				elseif(eax = IDC_BTN_REPLACE) then
					
					if (fres!=-1) then
					
						w.SendMessage(hred,w.EM_EXGETSEL,0,&ft.chrg);
						w.SendMessage(hred,w.EM_REPLACESEL,true, &replacebuf);
						zstr.len( &replacebuf );
						w.lstrlen( &replacebuf ); 
						add(eax,ft.chrg.cpMin);
						mov(ft.chrg.cpMin,eax);
						mov(eax,ft.chrg.cpMax);
						w.SendMessage(hred,w.EM_EXSETSEL,0,&ft.chrg);
						
					endif;
					Find();
					w.SetFocus(hFind);
	
				elseif (eax = IDC_BTN_REPLACEALL) then
					
					mov( true, findOpts.down );
					
					w.SendMessage (hred, w.EM_EXGETSEL, 0, &chrg);
					w.LockWindowUpdate(hred);
					w.SendMessage (hred, w.EM_SETSEL, 0, 0);
					Find();
					while (fres!=-1) do
						w.SendMessage(hWin, w.WM_COMMAND, IDC_BTN_REPLACE,0);
					endwhile;
					push (chrg.cpMax);
					pop (chrg.cpMin);
					w.SendMessage (hred, w.EM_EXSETSEL, 0, &chrg);
					w.LockWindowUpdate(NULL);
					w.SetFocus(hFind);
					
				elseif (eax = IDC_RBN_DOWN) then
					
					mov( true, findOpts.down );
					mov	(-1,fres);
					
				elseif (eax = IDC_RBN_UP) then
					
					mov( false, findOpts.down );
					mov( false, findOpts.matchpattern );
					w.CheckDlgButton( hWin, IDC_CHK_PATTERN, w.BST_UNCHECKED );
					mov	(-1, fres);
					
				elseif (eax = IDC_CHK_MATCHCASE) then
					
					w.IsDlgButtonChecked(hWin, IDC_CHK_MATCHCASE);
					if (eax) then
						mov( true, findOpts.matchcase );
						
					else
						
						mov( false, findOpts.matchcase );
						
					endif;
					mov	(-1, fres);
					
				elseif (eax = IDC_CHK_WHOLEWORD) then
					
					w.IsDlgButtonChecked(hWin, IDC_CHK_WHOLEWORD);
					if (eax) then
						
						//or	(w.FR_WHOLEWORD, fr);
						mov( true, findOpts.wholeword );
						mov( false, findOpts.matchpattern );
						w.CheckDlgButton( hWin, IDC_CHK_PATTERN, w.BST_UNCHECKED );
						
					else
						
						//and(! w.FR_WHOLEWORD,fr);
						mov( false, findOpts.wholeword );
						
					endif;
					mov	(-1,fres);
					
				elseif( eax = IDC_CHK_PATTERN ) then
					
					w.IsDlgButtonChecked(hWin, IDC_CHK_PATTERN);
					if (eax) then
						
						mov( false, findOpts.wholeword );
						mov( true, findOpts.matchpattern );
						w.CheckDlgButton( hWin, IDC_CHK_WHOLEWORD, w.BST_UNCHECKED );
						w.CheckRadioButton( hWin, IDC_RBN_DOWN, IDC_RBN_UP, IDC_RBN_DOWN );
						
					else
						
						mov( false, findOpts.matchpattern );
						
					endif;
					mov	(-1,fres);

				endif;
	
	
			elseif( edx = w.EN_UPDATE ) then
	
				push( ebx );
				mov( eax, ebx );
				if( w.SendDlgItemMessage(hWin, ebx, w.EM_GETMODIFY, 0, 0 )) then
	
					if (ebx = IDC_FINDTEXT) then
	
						w.SendDlgItemMessage(hWin, ebx, w.WM_GETTEXT, @elements(findbuf)-1, &findbuf);
						mov	(-1, fres);
						
					elseif( ebx = IDC_REPLACETEXT) then
						w.SendDlgItemMessage(hWin, ebx, w.WM_GETTEXT, @elements(replacebuf)-1, &replacebuf);
						mov	(-1, fres);
						
					endif;
					
					w.SendDlgItemMessage( hWin, ebx, w.EM_SETMODIFY, false, 0 );
				endif;
				
				pop( ebx );
	
			endif;
			
		elseif (eax = w.WM_ACTIVATE) then
			//w.GetDlgItem( hWin, IDC_FINDTEXT );
			//w.SetFocus(eax);
			w.SetFocus( hFind );
	
		elseif (eax = w.WM_CLOSE) then
			w.DestroyWindow(hFind);
			mov	(0,hFind);
			w.SetFocus(hred);
		else
			mov	(false, eax);
			popabi;
			exit Proc_FindDlg;
		endif;
		mov	(true, eax);
		popabi;
	end Proc_FindDlg;	


	initWindow	:procedure { @noframe };
	
		// look for file config_file, if exists,
		// read settings from it.
		// expand this as more settings are added
		// other pre-window creation initialization goes here
		// register and create window.
		
		// returns:
		// 	success = true in eax
		//	failure = false in eax 
		
	begin initWindow;
		
		w.GetModuleHandle( NULL );
		mov( eax, hinst );
		
		w.LoadLibrary( RichEditDLL );
		if (eax = NULL ) then
			Error( s_missingDLL );
			xor(eax,eax);
			ret();
	    endif;
	    
		mov	(eax,hredDLL);
		
		w.InitCommonControls();
		str.cpy( s_untitled, filepath );

		mov( 0, findbuf[0] );
		mov( 0, replacebuf[0] );
		
		zstr.cpy( (type zstring s_fontname ), &logfont.lfFaceName );
		mov( -12, logfont.lfHeight );
		mov( 400, logfont.lfWeight );
		
		getConfigPath( hide.strbuf );
		if( filesys.exists( hide.strbuf ) ) then
			
			// config file exists, read it and
			// apply settings as per file.
			config.create_file( hide.strbuf );
			config.readUns( s_window, "xPos" );
			mov( eax, settings.xPos );
			config.readUns( s_window, "yPos" );
			mov( eax, settings.yPos );
			config.readUns( s_window, "width" );
			mov( eax, settings.width );
			config.readUns( s_window, "height" );
			mov( eax, settings.height );
			
			config.readBin( s_text, s_font, &logfont, @size( logfont ) );
			config.readHex( s_text, s_background_color);
			mov( eax, info.backColor );
			config.readHex( s_text, s_text_color);
			mov( eax, info.textColor );

			config.readBin( s_text, s_custcolors, &customColors, @size( customColors ) );
			config.readBin( s_text, s_find, &findOpts, @size( findOpts ) ); 
			
		else
			
			// no file exists, create one
			// and set up with default settings.
			
			config.create();
			config.writeUns( s_settings, s_tabs, 4 );	// default 4 chars tab stop
			getConfigPath( hide.strbuf );
			config.writeFileName( hide.strbuf );

			// some hard coded defaults
			mov( 10, settings.xPos );
			mov( 10, settings.yPos );
			mov( 640, settings.width );
			mov( 400, settings.height );
			
			mov( color_white, info.backColor);
			mov( color_black, info.textColor);
			
		endif;		

		w.CreateFontIndirect( &logfont );
		mov( eax, hfont );
		
		// main window created here
		// describe and register the window class
		mov( @size(w.WNDCLASSEX), wc.cbSize );
		mov( w.CS_HREDRAW | w.CS_VREDRAW, wc.style );
		mov( &WndProc, wc.lpfnWndProc );
		mov( NULL, wc.cbClsExtra );
		mov( NULL, wc.cbWndExtra );
		mov( hinst, wc.hInstance );
		mov( w.COLOR_BTNFACE+1, wc.hbrBackground );
		mov( ClassName, wc.lpszClassName );
		
		w.LoadIcon(hinst, val ID_JAKAL);
		mov( eax, wc.hIcon );
		mov( eax, wc.hIconSm );
		w.LoadCursor( NULL, val w.IDC_ARROW );
		mov( eax,wc.hCursor );
		
		// register the window class
		if ( ! w.RegisterClassEx( wc )) then
			Error( "Unable to register Window Class");
			ret();
		endif;
			
		// create the window
		w.CreateWindowEx(
				NULL,					// dwExStyle
				ClassName,				// lpClassName
				AppName,				// lpWindowName
				w.WS_OVERLAPPEDWINDOW,	// dwStyle
				settings.xPos,			// x
				settings.yPos,			// y
				settings.width,			// nWidth
				settings.height,		// nHeight
				NULL,					// hWndParent
				NULL,					// hMenu
				hinst,					// hInstance
				NULL );					// lpParam
				
		if( ! eax ) then
			Error( "Unable to create window");
			ret();
		endif;
		
		w.ShowWindow( hwnd, w.SW_SHOWNORMAL );
		w.UpdateWindow( hwnd );

		ret();
	end initWindow;

	Cmd_File_Quit :procedure( hwin:dword; wparam:dword; lparam:dword );
	begin Cmd_File_Quit;
		
		w.SendMessage (hwin, w.WM_CLOSE, 0, 0 );
		
	end Cmd_File_Quit;

	updateStatus :procedure;
	
		var
			line	:uns32;
			
	
	begin updateStatus;
		
		getInfo();		
		mov( info.line.number, eax );
		inc( eax );
		conv.u32ToStr( eax, 20, ' ', hide.strbuf );
		str.trim( hide.strbuf );
		str.put( strbuf, "Ln: ", hide.strbuf, "   " );
		conv.u32ToStr( info.charIndex, 20,' ', hide.strbuf );
		str.trim( hide.strbuf );
		str.put2( strbuf, "Col: ", hide.strbuf, "   " );
		
		w.SendMessage( hred, w.EM_GETLINECOUNT, 0, 0 );
		conv.u32ToStr( eax, 20,' ', hide.strbuf );
		str.trim( hide.strbuf );
		str.put2( strbuf, "Lns: ", hide.strbuf );
		
		w.SendMessage( hstatus, w.SB_SETTEXT, 0, strbuf ); 
		
		if( info.ins_ovr ) then
			w.SendMessage( hstatus, w.SB_SETTEXT, 1, s_overwrite );
		else
			w.SendMessage( hstatus, w.SB_SETTEXT, 1, s_insert );
		endif;
		
		if( config.readBool( s_settings, s_readonly )) then
			w.SendMessage( hstatus, w.SB_SETTEXT, 2, s_r );
		else
			w.SendMessage( hstatus, w.SB_SETTEXT, 2, s_b );
		endif;
		
		if( info.is_marked ) then
			w.SendMessage( hstatus, w.SB_SETTEXT, 3, s_mark );
		else
			w.SendMessage( hstatus, w.SB_SETTEXT, 3, s_b );
		endif;
		
	end updateStatus;

	Msg_Create :procedure( hwin:dword; wparam:dword; lparam:dword );
	begin Msg_Create;
		
		mov(hwin, eax);
		mov(eax, hwnd);
		w.CreateMenu();
		mov(eax, hmenu);
		w.SetMenu(hwnd, hmenu);
		//w.GetMenu( hwnd );
		//mov( eax, hmenu );
		AddMenus();
		w.GetSubMenu( hmenu, 1 );
		mov( eax, hcontextmenu );
		w.DragAcceptFiles( hwnd, true );

		w.CreateStatusWindow( w.WS_CHILD, NULL, hwnd, IDC_SBAR );
		mov( eax, hstatus );
		w.SendMessage( eax, w.SB_SETPARTS, STATUS_PARTS, &statusParts );


		mov( 	w.ES_AUTOVSCROLL | w.ES_LEFT | w.ES_MULTILINE |
				w.ES_NOHIDESEL | w.ES_WANTRETURN |
				w.WS_CHILD | w.WS_CLIPSIBLINGS | w.WS_HSCROLL | w.ES_AUTOHSCROLL |
				w.WS_VSCROLL | w.WS_VISIBLE,
				edstyle );
					
				
		// create edit window
		w.CreateWindowEx( w.WS_EX_CLIENTEDGE, s_resedClass, NULL,
					edstyle, 0, 0, 0, 0, hwnd, hcontextmenu, hinst, NULL );
		
		mov( eax, hred );
		w.SendMessage( hred, w.EM_SETEVENTMASK, 0, w.ENM_SELCHANGE | w.ENM_KEYEVENTS
						| w.ENM_MOUSEEVENTS );
		//dbg.put("hred = ", hred );
		
		setFormat();
		w.SetFocus( hred );
		
		if( config.readBool( s_settings, s_wrap )) then
			
			w.CheckMenuItem( hmenu, IDM_WRAP, w.MF_BYCOMMAND | w.MF_CHECKED );
			w.SendMessage( hred, w.EM_SETTARGETDEVICE, NULL, 0 );
		else
			w.SendMessage( hred, w.EM_SETTARGETDEVICE, NULL, 1 );			
		endif;
		
		if( config.readBool( s_settings, s_readonly )) then
			
			w.CheckMenuItem( hmenu, IDM_READONLY, w.MF_BYCOMMAND | w.MF_CHECKED );
			or( w.ES_READONLY, edstyle );
		endif;
		
		
		// update menu
		dbg.put("updatemenu");
		if( config.isSectionDefined( s_recent ) ) then
			updateMenu();
		endif;
		
		if( config.readBool( s_settings, s_autosave ) ) then
			w.CheckMenuItem( hmenu, IDM_AUTO, w.MF_BYCOMMAND | w.MF_CHECKED);
		endif;
		
		if( config.readBool( s_settings, s_autoindent ) ) then
			w.CheckMenuItem( hmenu, IDM_AUTOINDENT, w.MF_BYCOMMAND | w.MF_CHECKED);
		endif;
		
		if( config.readBool( s_settings, s_topwindow )) then

			w.CheckMenuItem( hmenu, IDM_PEG, w.MF_BYCOMMAND | w.MF_CHECKED );
			w.SetWindowPos( hwnd, w.HWND_TOPMOST, 0, 0, 0, 0, 0 );		

		endif;
		
		if( config.readBool( s_settings, s_clearexit ) ) then
			
			w.CheckMenuItem( hmenu, IDM_CLEAREXIT, w.MF_BYCOMMAND | w.MF_CHECKED );
			
		endif;
		
		if( config.readBool( s_settings, s_recentnew ) ) then
			
			w.CheckMenuItem( hmenu, IDM_RECENTNEW, w.MF_BYCOMMAND | w.MF_CHECKED );
			
		endif;
			
		if( config.readBool( s_settings, s_openrecent ) ) then
			
			w.CheckMenuItem( hmenu, IDM_OPENRECENT, w.MF_BYCOMMAND | w.MF_CHECKED );
			
		endif;
		
		if( config.readBool( s_settings, s_rememberpos ) ) then
			w.CheckMenuItem( hmenu, IDM_REMEMBERPOS, w.MF_BYCOMMAND | w.MF_CHECKED );
		endif;
		
		if( config.readBool( s_window, s_status ) ) then
			
			w.CheckMenuItem( hmenu, IDM_VIEW_STATUS, w.MF_BYCOMMAND | w.MF_CHECKED );
			w.ShowWindow( hstatus, true );
			
		endif;
		
		w.EnableMenuItem( hmenu, IDM_OPTIONS_DECRYPTAES, w.MF_BYCOMMAND | w.MF_GRAYED );


		// check for a filename passed as an argument and try to open that file.
		// if file doesn't exist, start new document with that filename.
		
		arg.c();
		if( eax > 1 ) then
			
			// get an argument, see if it is a file that exists,
			// if so, open it.
			
			arg.v( 1 );
			w.GetLongPathName( eax, &buffer, @size(buffer) -1 );
			if (eax) then
				
				// file path copied, try to open it.
				
				str.cpyz( &buffer, hide.strbuf );
				loadFile( hide.strbuf );
				if (eax) then
					jmp skipOpenRecent;
				endif;
			else
				
				// there is no file, create a new document with name passed on command line
				filesys.gwd( filepath );
				str.cat ("\", filepath);
				arg.v(1);
				str.catz (eax, filepath); 
				jmp skipOpenRecent;
			endif;
		endif;
		
		// no file requested as an argument,
		// check config to see if we want to open the most recent document
		
		if( config.readBool( s_settings, s_openrecent ) ) then
			
			// we want to open the most recent file. do we have a recent file to open?
			
			if( config.isSectionDefined( s_recent )) then
				
				config.readItem( s_recent, 0, hide.strbuf );
				loadFile( hide.strbuf );
				if( ! eax ) then
					
					// the file we want to open doesn't exit anymore. remove it from our list.
					config.deleteItem( s_recent, 0 );
					updateMenu();
				endif;
				
				// do we want to move the cursor to the position it was when the file was closed?
				
				if( config.readBool( s_settings, s_rememberpos )) then
					config.readUns( s_settings, "cpMin");
					mov( eax, chrg.cpMin );
					config.readUns( s_settings, "cpMax");
					mov( eax, chrg.cpMax );
					w.SendMessage( hred, w.EM_EXSETSEL, 0, &chrg );
					w.SendMessage( hred,w.EM_SCROLLCARET,0,0 );
					updateStatus();
				endif;
				
			endif;
			
		endif;
		
		skipOpenRecent:	
		setWindowTitle();
		updateStatus();
		
		xor( eax, eax );
		
	end Msg_Create;

	Msg_Context :procedure( hwnd:dword; wParam:dword; lParam:dword );
		var
			pt	:w.POINT;
		
	begin Msg_Context;
		mov (lParam, eax);
		if (eax = -1) then
			w.GetCaretPos (pt);
			w.GetFocus();
			mov (eax, edx);
			w.ClientToScreen (edx, pt);
		else
			and ($ffff, eax);
			mov (eax, pt.x);
			mov (lParam, eax);
			shr (16, eax);
			mov (eax, pt.y);
		endif;
		
		mov (wParam, eax);
		if (eax = hred) then
			w.GetMenu (hwnd);
			w.GetSubMenu (eax, 1);	// edit menu, 2nd item
			w.TrackPopupMenu(eax, w.TPM_LEFTALIGN | w.TPM_RIGHTBUTTON, pt.x,pt.y,0,hwnd,NULL);
		endif;
		
		xor( eax, eax );
		
	end Msg_Context;
	
	getPassword :procedure( dest:string ) {@returns("EAX") };
	begin getPassword;
		
		w.DialogBoxParam( hinst, val ID_INPUT, hwnd, &Proc_Input, s_inputpwd );
		if( return > 0 ) then
			str.cpy( return, dest );
			str.free( return );
			or( 1, eax );
			
		else
			xor( eax, eax );
		endif;
		
	end getPassword;

	setTabWidth :procedure { @noframe, @returns("EAX") };
	begin setTabWidth;
		w.DialogBoxParam( hinst, val ID_INPUT, hwnd, &Proc_Input, s_inputtab );
		if( return > 0 ) then
			try
				conv.strTou32( return, 0 );
				
			anyexception
				xor( eax, eax );
			endtry;
		else
			xor( eax, eax );
		endif;
		ret();
	end setTabWidth;

	 
	Msg_Close :procedure( hwin:dword; wparam:dword; lparam:dword );
	begin Msg_Close;
	
	 	getConfirm();
		if (!eax) then
		 	w.SendMessage(hwin, w.WM_DESTROY, 0, 0 );
		 	
		endif;
		
		xor( eax, eax );
		
	end Msg_Close;


	Msg_Destroy :procedure( hwin:dword; wparam:dword; lparam:dword );

		var
			wndpos	:w.WINDOWPLACEMENT;
			rect		:rect_t;
			
	begin Msg_Destroy;
	
		dbg.put("destroy");
		getInfo();
		
		w.GetWindowPlacement( hwin, wndpos );
		w.GetWindowRect( hwin, rect );
		mov( rect.left, settings.xPos );
		mov( rect.top, settings.yPos );
		mov( rect.right, eax );
		sub( rect.left, eax );
		mov( eax, settings.width );
		mov( rect.bottom, eax );
		sub( rect.top, eax );
		mov( eax, settings.height );
		
		config.writeUns( s_window, "xPos", settings.xPos );
		config.writeUns( s_window, "yPos", settings.yPos );
		config.writeUns( s_window, "width", settings.width );
		config.writeUns( s_window, "height", settings.height );
		config.writeBin( s_text, s_find, &findOpts, @size( findOpts ) );
		
		config.writeUns( s_settings, "cpMin", info.cursor.cpMin );
		config.writeUns( s_settings, "cpMax", info.cursor.cpMax );
		
		if( config.readBool( s_settings, s_clearexit ) ) then
			
			dbg.put("deleting recent");
			config.deleteSection( s_recent );

		endif;

		
		getConfigPath( hide.strbuf );
		config.writeFileName( hide.strbuf );
		
	 	w.PostQuitMessage( NULL );
	 	xor( eax, eax );
			
	end Msg_Destroy;


	getLineInfo :procedure(var line:LineInfo);
		
		// input expects a LineInfo structure with the
		// .line field containing the desired line information
		// will fill the rest of the structure.
		// returns 0 if no line is available
		
	begin getLineInfo;
		USE (EBX);
		mov( line, ebx );
		w.SendMessage( hred, w.EM_LINEINDEX, (type LineInfo [ebx]).number, 0 );
		if( (type int32 eax) >= 0 ) then
			mov( eax, (type LineInfo[ebx]).index );
			w.SendMessage( hred, w.EM_LINELENGTH, eax, 0 );
			mov( eax, (type LineInfo[ebx]).length );
		else
			xor( eax, eax );
		endif;
		ENDUSE;
	end getLineInfo;

	
	getInfo: procedure;
	
		// collects informaiton about the edit state
		// and stores it in the info structure
	
	begin getInfo;
		
		w.SendMessage( hred, w.EM_EXGETSEL, 0, &info.cursor);
		w.SendMessage( hred, w.EM_EXLINEFROMCHAR, 0, info.cursor.cpMin );
		mov( eax, info.line.number );
		getLineInfo(info.line);
		mov( info.cursor.cpMin, eax );
		sub( info.line.index, eax );
		mov( eax, info.charIndex );

	end getInfo;

	Msg_Notify :procedure( hwin:dword; wparam:dword; lparam:dword );
	
		static
		ctrl_down	:boolean := false;
		shift_down	:boolean := false;

		// probably need to implement accelerator nonsense to make this key work
		// using syskeydown/up works, but can't get rid of annoying bleeps and
		// can't intercept alt key. it always gets passed to the parent window
		// no matter what I return in eax.
		alt_down	:boolean := false;		
	
	begin Msg_Notify;
		
		//pushabi;
		//dbg.separator;
		
		mov( lparam, edx );
		mov( (type w.NMHDR[EDX]).code, eax );
			
		if( eax = w.EN_SELCHANGE ) then
			
			updateStatus();
			updateTitle();

		elseif( eax = w.EN_MSGFILTER ) then
			
			// should return zero if the control will process
			// and return 1 if the control should ignore
			
			mov((type w.MSGFILTER[EDX]).msg, eax );
			mov((type w.MSGFILTER[EDX]).wParam, ebx);

			if( eax = w.WM_KEYUP ) then
				
				switch( ebx );				
						
					case( w.VK_SHIFT )
						mov( false, shift_down );
						
					case( w.VK_CONTROL )	
						mov( false, ctrl_down );
					
					case( w.VK_INSERT )
						xor( 1, info.ins_ovr );
					
					
					default
				endswitch;
				updateStatus();
				or( 1, eax );
				jmp done;

			elseif( eax = w.WM_KEYDOWN ) then

				// key down state, see if any control keys
				// are pressed
				
				switch( ebx );
						
					case( w.VK_SHIFT )
						mov( true, shift_down );
						
					case( w.VK_CONTROL )	
						mov( true, ctrl_down );
					
					
//bm=commands
					// process all commands and keyboard shortcuts here
					
					// custom keyboard commands
					
					case( w.VK_D )
						if( ctrl_down ) then
							
							getInfo();
							inc( info.cursor.cpMin );
							w.SendMessage( hred, w.EM_EXSETSEL, 0, &info.cursor );
							w.SendMessage( hred, w.EM_REPLACESEL,true, s_empty );

						endif;
						
					case( $DC )  // VK_OEM_5 .. backslash / pipe key
						if( ctrl_down ) then
							
							// cut current line
							
							getInfo();
							mov( info.line.index, eax );
							mov( eax, info.cursor.cpMin );
							add( info.line.length, eax );
							inc( eax ); // consume carriage return
							mov( eax, info.cursor.cpMax );
							w.SendMessage( hred, w.EM_EXSETSEL, 0, &info.cursor );
							w.SendMessage(hred, w.WM_CUT,0,0);
						endif;
					
					case( w.VK_F )
						if( ctrl_down ) then
							Msg_Command( hwnd, IDM_FIND,0 );
						endif;
					
					case( w.VK_G )
						if( ctrl_down ) then
							Msg_Command( hwnd, IDM_EDIT_GOTO,0 );
						endif;
					
					case( w.VK_I )
						
						if( ctrl_down ) then

							// remove default ctrl-i behavior
							while ( w.PeekMessage( msg, hred, w.WM_KEYFIRST, w.WM_KEYLAST, w.PM_REMOVE)) do
							endwhile;
								
							// move cursor up
							
							getInfo();
							if( want_pos = 0 ) then
								mov( info.charIndex, eax );
								mov( eax, want_pos );
							endif;

							// if we are at line 0, no point in doing anything);
							if( info.line.number > 0 ) then
								mov( info.line.number, eax);
								dec( eax );
								mov( eax, queryLine.number );
								getLineInfo( queryLine ); // info of prev. line
								//mov( info.charIndex, eax );
								mov( want_pos, eax );
								if( queryLine.length >= eax ) then

									add( queryLine.index, eax );
									
								else
									mov( queryLine.length, eax );
									add( queryLine.index, eax );
								endif;
								w.SendMessage( hred, w.EM_SETSEL, eax, eax );
								w.SendMessage( hred, w.EM_SCROLLCARET, 0, 0);
							endif;	
						endif;
						
				
					case( w.VK_J )
					
						if( ctrl_down ) then
							
							
							while ( w.PeekMessage( msg, hred, w.WM_KEYFIRST, w.WM_KEYLAST, w.PM_REMOVE)) do
							endwhile;
							
							getInfo();
							
							// move to beginning of line
							if( shift_down ) then
								mov( info.line.index, eax );
								if( info.charIndex = 0 && eax > 0 ) then
									
									// we're at the beginning of line, go to the beginning of prev line.
									
									dec (eax );
									w.SendMessage( hred, w.EM_SETSEL, eax, eax );
									getInfo();
								endif;
								w.SendMessage( hred, w.EM_SETSEL, info.line.index, info.line.index );
								jmp done;
							endif;
							
							// move cursor left 1 character
							mov( info.cursor.cpMin, eax );
							if( eax ) then
								dec( eax );
								w.SendMessage( hred, w.EM_SETSEL, eax, eax );
								w.SendMessage( hred, w.EM_SCROLLCARET, 0, 0);
							endif;
						endif;
						
					case( w.VK_K )
						
						if( ctrl_down) then
							
							// consume the key_up command so it won't send to wm_char
							while ( w.PeekMessage( msg, hred, w.WM_KEYFIRST, w.WM_KEYLAST, w.PM_REMOVE)) do
							endwhile;

							// move cursor down							
							
							getInfo();
							if( want_pos = 0 ) then
								mov( info.charIndex, eax );
								mov( eax, want_pos );
							endif;
							
							mov( info.line.number, eax );
							inc( eax );
							mov( eax, queryLine.number );
							getLineInfo( queryLine );
							
							//mov( info.charIndex, eax );
							mov( want_pos, eax );
							if( queryLine.length >= eax ) then
								
								add( queryLine.index, eax );
								
							else
								mov( queryLine.length, eax );
								add( queryLine.index, eax );
							endif;
							w.SendMessage( hred, w.EM_SETSEL, eax, eax );
							w.SendMessage( hred, w.EM_SCROLLCARET, 0, 0);
							
						endif;
						
					case( w.VK_L )
						
						
						// move to beginning of line
						if( shift_down ) then
							mov( info.line.length, eax );
							if( info.charIndex = eax ) then
								
								// we're at the end of line, go to the end of next line.
								add( info.line.index, eax );
								inc( eax ); // go over the carriage return
								w.SendMessage( hred, w.EM_SETSEL, eax, eax );
								getInfo();
							endif;
							mov( info.line.length, eax );
							add( info.line.index, eax );
							w.SendMessage( hred, w.EM_SETSEL, eax, eax );
							jmp done;
						endif;
						
						// move cursor right 1 character
						if( ctrl_down ) then
							
							while ( w.PeekMessage( msg, hred, w.WM_KEYFIRST, w.WM_KEYLAST, w.PM_REMOVE)) do
							endwhile;

							// control shift L makes list
							if( !shift_down ) then
								getInfo();
								mov( info.cursor.cpMin, eax );
								inc( eax );
								w.SendMessage( hred, w.EM_SETSEL, eax, eax );
								w.SendMessage( hred, w.EM_SCROLLCARET, 0, 0);
							endif;
						endif;
						
					case( w.VK_N )
						if( ctrl_down ) then
							Msg_Command( hwnd, IDM_NEW, 0 );
						endif;
					
					case( w.VK_O )
						if( ctrl_down ) then
							Msg_Command( hwnd, IDM_OPEN,0 );
						endif;	
					
					case( w.VK_P )
					
					case( w.VK_S )
						if( ctrl_down && shift_down ) then
							Msg_Command( hwnd, IDM_SAVEAS,0 );
						elseif( ctrl_down ) then
							Msg_Command( hwnd, IDM_SAVE,0 );
						endif;
					
					case( w.VK_T )
						if( ctrl_down ) then
							Msg_Command( hwnd, IDM_PEG,0 );
						endif;
					
					case( w.VK_F2 )
						Msg_Command( hwnd, IDM_AUTO,0 );
						
					case( w.VK_F3 )
						if( ctrl_down ) then
							Msg_Command( hwnd, IDM_FINDPREV,0 );
						else
							Msg_Command( hwnd, IDM_FINDNEXT,0 );
						endif;
						
					case( w.VK_F4 )
						Msg_Command( hwnd, IDM_WRAP,0 );
						
					case( w.VK_F5 )
						Msg_Command( hwnd, IDM_TIME,0 );
						
					case( w.VK_F6 )
						Msg_Command( hwnd, IDM_READONLY,0 );
						
					case( w.VK_COMMA )
						
						// same as ctrl-left
						if( ctrl_down ) then
							w.PostMessage( hred, w.WM_KEYDOWN, w.VK_LEFT, 0 );
						endif;
						
					case( w.VK_PERIOD )
					
						// same as ctrl-right
						if( ctrl_down ) then
							w.PostMessage( hred, w.WM_KEYDOWN, w.VK_RIGHT, 0 );
						endif;

					case( w.VK_ESCAPE )

						w.SendMessage(hwnd,w.WM_CLOSE,0,0 );
						or( 1, eax );
						jmp done;
					default;
				endswitch;
				
			elseif ( eax = w.WM_CHAR ) then

				
				switch( ebx );
					
					case( w.VK_SPACE )
						
						if( ctrl_down ) then
							
							// toggle mark state
							
							getInfo();
							
							if( info.is_marked ) then
								
								// close mark and set selection
								// find the start and end of the selection
								
								mov( info.markIndex, eax );
								if( eax < info.cursor.cpMin ) then
									push( info.cursor.cpMin );
									mov( eax, info.cursor.cpMin );
									pop( info.cursor.cpMax );
								else
									mov( eax, info.cursor.cpMax );
								endif;
								
								w.SendMessage( hred, w.EM_EXSETSEL, 0, &info.cursor );
								
							else
								
								// start a mark
								mov( info.cursor.cpMin, eax );
								mov( eax, info.markIndex );
								
							endif;
							
							// toggle mark
							xor( 1, info.is_marked );
							
							or( 1, eax );
							jmp done;
							
						endif;
						
					case( w.VK_RETURN )
						
						if( config.readBool( s_settings, s_autoindent ) ) then

							w.SendMessage( hred, w.EM_LINEFROMCHAR, -1, 0);
							dec( eax );
							mov( szLINEBUFFER-1, (type word buffer[0]));
							w.SendMessage( hred, w.EM_GETLINE, eax, &buffer );
							if( eax ) then
								xor( ecx, ecx );
								while( eax ) do
									mov( buffer[ecx], dl );
									if( dl == $09 ) then
										inc( ecx );
									else
										break;
									endif;
									dec( eax );
								endwhile;
								
								// if we are here, then ecx contains number of tabs
								str.cpy("", strbuf );
								if( ecx ) then
									while( ecx ) do
										str.cat( "	", strbuf);
										dec( ecx );
									endwhile;
									w.SendMessage( hred, w.EM_GETSEL, &chrg.cpMin, &chrg.cpMax);
									w.SendMessage( hred, w.EM_REPLACESEL,true, strbuf );
									w.SendMessage( hred, w.EM_SCROLLCARET,0,0);
								endif;
							endif;
						endif;
						
					default;
						
						mov( 0, want_pos );
						mov( false, info.is_marked );
					
				endswitch;
			
			elseif( eax = w.WM_LBUTTONDOWN ) then
				
				mov( 0, want_pos );

			endif;
				
		endif;
		
		// return default - control should handle key
		xor( eax, eax );
		done:
	end Msg_Notify;

	// handle menu commands
	// perhaps use this to handle custom commands
	Msg_Command :procedure( hwin:dword; wparam:dword; lparam:dword );
	begin Msg_Command;
		mov	(wparam,eax);
		and	($0ffff,eax);
		
		switch( eax );
		case( IDM_NEW )
			
			getConfirm();
			if (!eax) then	
				
				w.SetWindowText( hred, 0 );		// clear edit window
				str.cpy( s_untitled, filepath );
				setWindowTitle();
				
			endif;
			w.SetFocus(hred);
		
		case( IDM_OPEN )
		
			getConfirm();
			if (!eax) then
			
				fileOpen(); 
	
			endif;	
			w.SetFocus(hred);
			
		case( IDM_INST )
			
			newInstance( NULL );
			
		case( IDM_SAVE )
		
			checkSave();
			w.SetFocus(hred);
			
		case( IDM_SAVEAS )
		
			SaveAs();
			w.SetFocus(hred);
			
	   	case( IDM_CUT )
		
			w.SendMessage(hred, w.WM_CUT,0,0);
			
		case( IDM_COPY )
		
			w.SendMessage(hred, w.WM_COPY,0,0);
			
		case( IDM_PASTE )
		
			w.SendMessage(hred, w.WM_PASTE,0,0);
			w.SendMessage(hred, w.EM_SETMODIFY, true,0); 	
			
		case( IDM_SELECTALL )
			
			selectAll();
			
		case( IDM_UNDO )
		
			w.SendMessage(hred, w.EM_UNDO,0,0);
			
		case( IDM_REDO )
		
			w.SendMessage(hred, w.EM_REDO,0,0);
			
		case( IDM_FIND, IDM_REPLACE )
			if (!hFind) then
				GetSelText (&findbuf);
				w.CreateDialogParam(hinst,val ID_FINDDLG,hwnd, &Proc_FindDlg,false);
			else
				w.SetFocus(hFind);
			endif;
		
		case( IDM_FINDNEXT )
			
			mov( true, findOpts.down );
			
			if (! hFind) then
				GetSelText(&findbuf);
			endif;
			mov( findbuf[0], al );
			test(al,al);
			if (@nz) then
				Find(); //(w.FR_DOWN);
			endif;
			
		case(IDM_FINDPREV )
			
			mov( false, findOpts.down );
			
			if (! hFind) then
				GetSelText(&findbuf);
			endif;
			mov (findbuf[0], al);
			test(al,al);
			if (@nz) then
				Find(); //(0);
			endif;
			
		case( IDM_EDIT_GOTO )
			
			w.DialogBoxParam( hinst, val ID_INPUT, hwnd, &Proc_Input, s_inputlinen );
			if( return > 0 ) then
				
				dbg.put("query :", return );
				
				try
					conv.strTou32( return, 0 );
					dec(eax);
					w.SendMessage( hred, w.EM_LINEINDEX, eax, 0 );
					w.SendMessage( hred, w.EM_SETSEL, eax, eax );
					w.SendMessage( hred, w.EM_SCROLLCARET, 0, 0 );
					
				anyexception
					
					str.put( hide.strbuf, "Can't go to line ", return );
					warning( hide.strbuf );
					
				endtry;
					
				str.free( return );
				mov( 0, return );
				
			endif;
			
		case( IDM_TIME )
	
			InsertTime();
			
		case( IDM_FONT )
		
			selectFont();
			w.SetFocus(hred);
			
		case(IDM_BACKGROUND )
	
			selectColor();
			w.SetFocus(hred);
			
		case(IDM_AUTO ) 
			
			if( config.readBool( s_settings, s_autosave ) ) then
			
				w.CheckMenuItem( hmenu, IDM_AUTO, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
				
			else
				
				w.CheckMenuItem( hmenu, IDM_AUTO, w.MF_BYCOMMAND | w.MF_CHECKED );
				mov( true, eax );
				
			endif;
			
			config.writeBool( s_settings, s_autosave, al );
			
		case(  IDM_AUTOINDENT ) 
			
			if( config.readBool( s_settings, s_autoindent ) ) then
			
				w.CheckMenuItem( hmenu, IDM_AUTOINDENT, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
				
			else
				
				w.CheckMenuItem( hmenu, IDM_AUTOINDENT, w.MF_BYCOMMAND | w.MF_CHECKED );
				mov( true, eax );
				
			endif;
			
			config.writeBool( s_settings, s_autoindent, al );
						
		case ( IDM_WRAP) 

			if( config.readBool( s_settings, s_wrap ) ) then

				w.CheckMenuItem( hmenu, IDM_WRAP, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
				
			else
				
				w.CheckMenuItem( hmenu, IDM_WRAP, w.MF_BYCOMMAND | w.MF_CHECKED );
				mov( true, eax );
				
			endif;
			config.writeBool( s_settings, s_wrap, al );
			if( eax ) then
				w.SendMessage( hred, w.EM_SETTARGETDEVICE, NULL, 0 );
			else
				w.SendMessage( hred, w.EM_SETTARGETDEVICE, NULL, 1 );
			endif;
			
		case ( IDM_READONLY) 
			
			if( config.readBool( s_settings, s_readonly ) ) then

				w.CheckMenuItem( hmenu, IDM_READONLY, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
				
			else
				
				w.CheckMenuItem(hmenu, IDM_READONLY, w.MF_BYCOMMAND | w.MF_CHECKED);
				mov( true, eax );
				
			endif;
			config.writeBool( s_settings, s_readonly, al );
			w.SendMessage( hred, w.EM_SETREADONLY, eax, 0 );
			updateStatus();
			
		case ( IDM_CLEAREXIT) 

			if( config.readBool( s_settings, s_clearexit ) ) then

				w.CheckMenuItem( hmenu, IDM_CLEAREXIT, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
			else
				
				w.CheckMenuItem(hmenu, IDM_CLEAREXIT, w.MF_BYCOMMAND | w.MF_CHECKED);
				mov( true, eax );
			endif;
			config.writeBool( s_settings, s_clearexit, al );
			
		case ( IDM_RECENTNEW) 
			
			if( config.readBool( s_settings, s_recentnew ) ) then

				w.CheckMenuItem( hmenu, IDM_RECENTNEW, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
				
			else
				
				w.CheckMenuItem(hmenu, IDM_RECENTNEW, w.MF_BYCOMMAND | w.MF_CHECKED);
				mov( true, eax );
				
			endif;
			config.writeBool( s_settings, s_recentnew, al );
			
		case ( IDM_OPENRECENT) 

			if( config.readBool( s_settings, s_openrecent ) ) then

				w.CheckMenuItem( hmenu, IDM_OPENRECENT, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
				
			else
				
				w.CheckMenuItem(hmenu, IDM_OPENRECENT, w.MF_BYCOMMAND | w.MF_CHECKED);
				mov( true, eax );
				
			endif;
			config.writeBool( s_settings, s_openrecent, al );
			
		case(  IDM_REMEMBERPOS ) 
		
			if( config.readBool( s_settings, s_rememberpos ) ) then

				w.CheckMenuItem( hmenu, IDM_REMEMBERPOS, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
				
			else
				
				w.CheckMenuItem(hmenu, IDM_REMEMBERPOS, w.MF_BYCOMMAND | w.MF_CHECKED);
				mov( true, eax );
				
			endif;
			config.writeBool( s_settings, s_rememberpos, al );
			
		case ( IDM_PEG) 

			if( config.readBool( s_settings, s_topwindow ) ) then

				w.CheckMenuItem( hmenu, IDM_PEG, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				w.SetWindowPos(hwnd,w.HWND_NOTOPMOST,0,0,0,0,3);
				mov( false, eax );
				
			else
				
				w.CheckMenuItem(hmenu, IDM_PEG, w.MF_BYCOMMAND | w.MF_CHECKED);
				w.SetWindowPos(hwnd,w.HWND_TOPMOST,0,0,0,0,3);
				mov( true, eax );
				
			endif;
			config.writeBool( s_settings, s_topwindow, al );
		
		case(  IDM_SETTAB ) 
			
			if( setTabWidth() ) then
				config.writeUns( s_settings, s_tabs, eax );
				setFormat();
			endif;
			
		case(  IDM_OPTIONS_ENCRYPTAES ) 
			
			if( ! getConfirm() ) then
				if( getPassword( hide.strbuf ) ) then
					
					dbg.put("password :", hide.strbuf );
					mov( hide.strbuf, ecx );
					aes.init( aes.bits256, [ecx], str.length( hide.strbuf ) );
					str.cpy( filepath, strbuf );
					filesys.deleteExt( strbuf, strbuf );
					str.put2( strbuf, s_encext );
					aes.encrypt( filepath, strbuf );
					loadFile( strbuf );
					aes.free();
					
				endif;
			endif;
			
		case(  IDM_OPTIONS_DECRYPTAES ) 
			
			if( ! getConfirm() ) then
				if( getPassword( hide.strbuf ) ) then
					
					dbg.put("password :", hide.strbuf );
					mov( hide.strbuf, ecx );
					aes.init( aes.bits256, [ecx], str.length( hide.strbuf ) );
					str.cpy( filepath, strbuf );
					filesys.deleteExt( strbuf, strbuf );
					str.put2( strbuf, s_txtext );
					aes.decrypt( filepath, strbuf );
					loadFile( strbuf );
					aes.free();
	
				endif;
			endif;
			
		case(  IDM_VIEW_STATUS ) 
			
			if( config.readBool( s_window, s_status ) ) then
				
				config.writeBool( s_window, s_status, false );
				w.CheckMenuItem( hmenu, IDM_VIEW_STATUS, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				w.ShowWindow( hstatus, false );
				
			else
				
				config.writeBool( s_window, s_status, true );
				w.CheckMenuItem( hmenu, IDM_VIEW_STATUS, w.MF_BYCOMMAND | w.MF_CHECKED );
				w.ShowWindow( hstatus, true );
				
			endif;
			w.SendMessage( hwnd, w.WM_SIZE, 0, 0 );
			
		case ( IDM_ABOUT) 
		
			w.CreateDialogParam(hinst,val ID_ABOUT,hwnd,&AboutDlgProc,0);
	
		case ( IDM_DOCUMENTS) 
			
			if( filesys.exists( s_document ) ) then
				newInstance( s_document );
			else
				warning( s_missingDocs );
			endif;

		case( IDM_QUIT ) 
		
			 w.SendMessage(hwnd,w.WM_CLOSE,0,0);
		
		default;
			if( eax >= RECENT_MENU_START && eax <= RECENT_MENU_END ) then
				openRecent( eax );
			endif;
		endswitch;
		
		xor( eax, eax );

	end Msg_Command;

	
	WndProc :procedure( lparam:dword; wparam:dword; umsg:uns32; hwin:dword );
	
		// main window message handler
	
	begin WndProc;
		pushabi;
		mov(umsg,eax);
		mov(&message_table,edx);
		
		FOREVER
			mov( (type MsgProcPtr_t [edx]).MessageHndlr, ecx );
			IF( ecx = 0 ) THEN
				w.DefWindowProc( hwin, umsg, wparam, lparam );
				EXIT WndProc;
			ELSEIF( eax = (type MsgProcPtr_t [edx]).MessageValue ) THEN
	
				push( hwin );
				push( wparam );
				push( lparam );
				call( ecx );
				BREAK;
			ENDIF;
			add( @size( MsgProcPtr_t ), edx );
		ENDFOR;
	
		popabi;
	end WndProc;


begin SavageEd;

	initWindow();
	cmp( eax, 0 );
	je _exit;
	
	FOREVER
		w.GetMessage(msg,NULL,0,0);
		breakif( ! eax );
		w.IsDialogMessage( hFind, msg );
		continueif( eax );
		w.IsDialogMessage( hAbout, msg );
		continueif( eax );
		w.TranslateMessage( msg );
		w.DispatchMessage( msg );		
	ENDFOR;
	
	// tail free some resources
	w.DestroyWindow( hred );
	w.DeleteObject( hfont );
	w.FreeLibrary(hredDLL);

	mov( msg.wParam, eax );

	_exit:

end SavageEd;
