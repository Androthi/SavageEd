program SavageEd;

	#include("SavageEd.hhf")

	?@nodisplay 	:=true;
	?@nostackalign	:= true;

readonly

	version			:string := "SavageEd v0.10.45";

storage
	logfont			:w.LOGFONT;
	frflags			:dword;
	buffer			:byte[szLINEBUFFER];
	findbuf			:byte[300];
	replacebuf		:byte[300];
	ft				:w.FINDTEXTEX;
	fres			:int32;
	return			:string;	// returned from some dialogs. Doesn't need to be string type. 

	customColors:dword[16];
	find_range	:w.TEXTRANGE;
	
	config		:tConfig;
	window		:wnd_settings;
	align(4);
	
	proc_return		:boolean;	// hack needed to ignore a rogue WM_KEYUP being sent from the system after startup from commandline or by a keypress
	align(4);


static
	align(4);

	statusParts	:int32[STATUS_PARTS]:=[
				POS_LINES,
				POS_READONLY,
				POS_AUTO,
				POS_LINEBREAK,
				POS_MARK,
				POS_MODE
	];
	
	strtabs		:str.strvar( w.MAX_PATH ); // user specified tabs converted to spaces
	
	BufferList	:tBaseList;
	
	align(4);
	keystate	:byte[256];

	align(4);
	ctrl_down	:boolean;
	shift_down	:boolean;
	alt_down	:boolean;
	
	align(4);
	

	
proc

	selectFont :procedure;

		var			
			font_str	:string;
			choose_font:w.CHOOSEFONT;

	begin selectFont;
				
		mov( str.talloc( 1000 ), font_str );
		lea( esi, choose_font );
		mem2.fillMem( [esi], @size( choose_font ), 0 );
		mov( @size(choose_font), choose_font.lStructSize );
		mov( window.hwnd, eax );
		mov( eax, choose_font.hWndOwner );
		mov( &logfont, choose_font.lpLogFont );
		mov( w.CF_SCREENFONTS | w.CF_EFFECTS | w.CF_INITTOLOGFONTSTRUCT, choose_font.Flags );
		push( window.textColor );
		pop( choose_font.rgbColors );
		w._ChooseFont(choose_font);
		if (eax) then

			w.DeleteObject(window.hfont);
			w.CreateFontIndirect(logfont);
			mov( eax, window.hfont );
			push( choose_font.rgbColors );
			pop( window.textColor );
			setFont();
			config.writeHex( s_text, s_background_color, window.backColor);
			config.writeHex( s_text, s_text_color, window.textColor);

			config.writeInt( s_font, "Height", logfont.lfHeight );
			config.writeInt( s_font, "Width", logfont.lfWidth );
			config.writeInt( s_font, "Weight", logfont.lfWeight );
			
			movzx( logfont.lfItalic, eax );
			config.writeInt( s_font, "Italic", eax );
			movzx( logfont.lfPitchAndFamily, eax );
			config.writeInt( s_font, "Pitch", eax );
			str.cpyz (&logfont.lfFaceName, font_str );
			config.writeString( s_font, "Name", font_str );
			
		endif;
	end selectFont;
	
	selectColor :procedure { @returns("EAX") };
		
		var cc	:w.CHOOSECOLOR;
		
	begin selectColor;
		dbg.put ("selectColor");
		lea( eax, cc );
		mem2.fillMem( [eax], @size( w.CHOOSECOLOR ), 0 );
		mov( @size( cc ), cc.lStructSize );
		push(window.hwnd );
		pop( cc.hwndOwner );
		push( window.hinst );
		pop( cc.hInstance );
		mov( w.CC_RGBINIT, cc.Flags );
		mov( &customColors, cc.lpCustColors);
		push( window.backColor );
		pop( cc.rgbResult );
		w._ChooseColor( cc );
		if( eax ) then
			push( cc.rgbResult );
			pop( return );	// black color can be zero so we'll use this to return color value
			config.writeBin( s_text, s_custcolors, &customColors, @size( customColors ) );
			or( 1, eax );
		endif;
	end selectColor;

	saveConfig	:procedure;
		var	config_path:string;
	begin saveConfig;
		mov( str.talloc(1000), config_path);
		getConfigPath( config_path );
		config.writeFileName( config_path );
	end saveConfig;


	updateMenu :procedure;	
	
		// updates the recent files menu
		// based on user options
	
		var
			count	:uns32;
			build_str:string;
			
	begin updateMenu;
		dbg.put("updateMenu");

		mov( str.talloc( 1000 ), build_str );
		pushabi;
		if( window.hsubmenu <> 0 ) then
			w.DestroyMenu( window.hsubmenu );
			mov( 0, window.hsubmenu );
		endif;
			
		w.CreatePopupMenu();
		mov( eax, window.hsubmenu );
		mov( RECENT_MENU_START, ebx );
		config.getItemCount( s_recent );
		mov( eax, count );
		
		for( mov( 0, ecx ); ecx < count; inc( ecx ) ) do
			
			if( config.readItem( s_recent, ecx, build_str ) ) then
				USE( ECX, EBX );
				w.AppendMenu( window.hsubmenu, w.MF_BYPOSITION | w.MF_ENABLED | w.MF_STRING,
							ebx, build_str);
				ENDUSE;
			endif;
			inc( ebx );
		endfor;
		
		w.GetMenu( window.hwnd );
		w.GetSubMenu( eax, 0 );
		w.ModifyMenu( eax, 8, w.MF_BYPOSITION | w.MF_POPUP| w.MF_ENABLED,
					window.hsubmenu, s_recent );
		
		mov( window.buffer_focus, ebx );
		
		if( config.readBool( s_settings, s_wrap )) then
			
			w.CheckMenuItem( window.hmenu, IDM_WRAP, w.MF_BYCOMMAND | w.MF_CHECKED );
			w.SendMessage( editebx.hred, w.EM_SETTARGETDEVICE, NULL, 0 );
			mov( true, editebx.word_wrap );
		else
			w.SendMessage( editebx.hred, w.EM_SETTARGETDEVICE, NULL, 1 );
			mov( false, editebx.word_wrap );
		endif;
		
		if( config.readBool( s_settings, s_readonly )) then
			
			w.CheckMenuItem( window.hmenu, IDM_READONLY, w.MF_BYCOMMAND | w.MF_CHECKED );
		endif;
		
		if( config.readBool( s_settings, s_autosave ) ) then
			w.CheckMenuItem( window.hmenu, IDM_AUTO, w.MF_BYCOMMAND | w.MF_CHECKED);
		endif;
		
		if( config.readBool( s_settings, s_autoindent ) ) then
			w.CheckMenuItem( window.hmenu, IDM_AUTOINDENT, w.MF_BYCOMMAND | w.MF_CHECKED);
		endif;
		
		if( config.readBool( s_settings, s_tabsasspace ) ) then
			w.CheckMenuItem( window.hmenu, IDM_TAB_AS_SPACE, w.MF_BYCOMMAND | w.MF_CHECKED);
		endif;
		
		if( config.readBool( s_settings, s_topwindow )) then

			w.CheckMenuItem( window.hmenu, IDM_PEG, w.MF_BYCOMMAND | w.MF_CHECKED );
			w.SetWindowPos( window.hwnd, w.HWND_TOPMOST, 0, 0, 0, 0, 0 );		

		endif;
		
		if( config.readBool( s_settings, s_clearexit ) ) then
			
			w.CheckMenuItem( window.hmenu, IDM_CLEAREXIT, w.MF_BYCOMMAND | w.MF_CHECKED );
			
		endif;
		
		if( config.readBool( s_settings, s_recentnew ) ) then
			
			w.CheckMenuItem( window.hmenu, IDM_RECENTNEW, w.MF_BYCOMMAND | w.MF_CHECKED );
			
		endif;
			
		if( config.readBool( s_settings, s_openrecent ) ) then
			
			w.CheckMenuItem( window.hmenu, IDM_OPENRECENT, w.MF_BYCOMMAND | w.MF_CHECKED );
			
		endif;
		
		if( config.readBool( s_settings, s_rememberpos ) ) then
			w.CheckMenuItem( window.hmenu, IDM_REMEMBERPOS, w.MF_BYCOMMAND | w.MF_CHECKED );
		endif;
		
		if( config.readBool( s_window, s_status ) ) then
			
			w.CheckMenuItem( window.hmenu, IDM_VIEW_STATUS, w.MF_BYCOMMAND | w.MF_CHECKED );
			w.ShowWindow( window.hstatus, true );
			
		endif;
		
		config.readString( s_settings, "Line Break", build_str );
		if( str.eq( build_str, "CRLF" ))then
			w.CheckMenuItem( window.hmenu, IDM_CRLF, w.MF_BYCOMMAND | w.MF_CHECKED );
			w.CheckMenuItem( window.hmenu, IDM_LF, w.MF_BYCOMMAND | w.MF_UNCHECKED );
		else
			w.CheckMenuItem( window.hmenu, IDM_CRLF, w.MF_BYCOMMAND | w.MF_UNCHECKED );
			w.CheckMenuItem( window.hmenu, IDM_LF, w.MF_BYCOMMAND | w.MF_CHECKED );
		endif;
		
		if( config.readBool( s_settings, "Active URL" )) then
			w.CheckMenuItem( window.hmenu, IDM_ACTIVE_URL, w.MF_BYCOMMAND | w.MF_CHECKED );
		else
			w.CheckMenuItem( window.hmenu, IDM_ACTIVE_URL, w.MF_BYCOMMAND | w.MF_UNCHECKED );
		endif;
		w.DrawMenuBar( window.hwnd );
		
		//dbg.put("/updateMenu");
		popabi;
	end updateMenu;
	
	loadFile :procedure( filename:string );
	
		// load filename into the edit buffer
		var
			hfile	:dword;
			extract_str	:string;
			
	
	begin loadFile;
		dbg.put("loadFile :", filename);
		
		mov( str.talloc( 1000 ), extract_str );
		try
			fileio.open( filename, fileio.r );
			mov( eax, hfile );
			setText( hfile );
			fileio.close( hfile );
			mov( window.buffer_focus, ebx );
			str.cpy( filename, editebx.filepath );
			filesys.extractExt( filename, extract_str );
			checkLog();
			updateRecentLog();

			// clear the undo buffer since we probably made some formatting and alterations
			// to the file
			w.SendMessage( editebx.hred, w.EM_EMPTYUNDOBUFFER, 0, 0 );
			mov( MODE_INSERT, editebx.mode );
			mov( false, editebx.mark );
			or( 1, eax );
			
		anyexception
			
			str.put( extract_str, s_noopen, " :", filename );
			Error( extract_str, true );
			xor( eax, eax );
			
		endtry;
		
		dbg.put("/loadFile");
	end loadFile;

	fileOpen :procedure;
	
		// get a filename from openfile dialog
		// get it loaded into buffer
		var
			ofn	:w.OPENFILENAME;
			file_name	:string;
				
	begin fileOpen;
	
		NOTE( "a new version of this procedure will be needed to create a new edit list item"
			  "once multi-buffers and tab bar are implemented" )
	
		mov( str.talloc( 1000 ), file_name );
		lea( eax, ofn );
		mem2.fillMem( [eax], @size( ofn ), 0 );
		mov( @size( ofn ), ofn.lStructSize );
		mov( window.hwnd, ofn.hWndOwner );
		mov( window.hinst, ofn.hInstance );
		
		mov( &curdir, eax );
		mov( eax, ofn.lpstrInitialDir );
		
		mov( 0, buffer[0] );
		mov( &buffer, ofn.lpstrFile );
		mov( @elements(buffer)-1, ofn.nMaxFile );
		
		mov( w.OFN_PATHMUSTEXIST | w.OFN_FILEMUSTEXIST | w.OFN_LONGNAMES,ofn.Flags );
		w.GetOpenFileName( ofn );
		if( eax ) then
			str.cpyz( &buffer, file_name );
			loadFile( file_name );
		endif;

	end fileOpen;
		
	findNormal :procedure( opts:dword );
	
		// basic text search
	
	begin findNormal;
		
		mov( window.buffer_focus, ebx );
		mov( false, editebx.mark );
		move( &findbuf, ft.lpstrText);
		dbg.put("find normal : ");
		dbg.putz( ft.lpstrText );
		dbg.dumpmem( ft.lpstrText, 10 );

		w.SendMessage( editebx.hred, w.EM_FINDTEXTEX, opts, &ft );
		mov( eax, fres );
		if(eax != -1) then
	
			w.SendMessage( editebx.hred, w.EM_EXSETSEL, 0, &ft.chrgText );
			//w.SendMessage( editebx.hred,w.EM_SCROLLCARET,0,0 );
	
		else

			// done search, reset and start searching from top
			// or bottom
			if( window.find_mode.down ) then
				w.SendMessage( editebx.hred, w.EM_SETSEL, 0, 0 );
				mov( 0, ft.chrg.cpMin );
				
			else
				w.SendMessage( editebx.hred, w.WM_GETTEXTLENGTH, 0, 0 );
				w.SendMessage( editebx.hred, w.EM_SETSEL, eax, eax );
			endif;
		endif;
		
	end findNormal;
	
	findPattern :procedure( opts:dword );
		
		// uses pattern matching to search for text
		
		var
			hmem	:hide.memory;
			build_str:string;
			start_pos	:dword;
			end_pos		:dword;
			
	
	begin findPattern;
		dbg.enters( "findPattern" );
		
		mov( str.talloc( 1000 ), build_str );
		lea( eax, start_pos );
		lea( ecx, end_pos );
		mov( window.buffer_focus, ebx );
		w.SendMessage( editebx.hred, w.EM_GETSEL, eax, ecx );
		cmp( (type byte findbuf[0]), 0 );
		mov( 0, hmem );
		je retFalse;
		mov( false, editebx.mark );
		move( ft.chrg.cpMin, find_range.chrg.cpMin );
		w.SendMessage( editebx.hred, w.WM_GETTEXTLENGTH, 0, 0 );
		mov( eax, find_range.chrg.cpMax );
		sub( ft.chrg.cpMin, eax );
		
		add( 4, eax );
		mem.zalloc( eax );
		mov( eax, hmem );
		mov( eax, find_range.lpstrText );
		
		w.SendMessage( editebx.hred, w.EM_GETTEXTRANGE, 0, &find_range );
		mov( hmem, esi );
		str.cpyz( &findbuf, build_str );
		dbg.put("pattern find :", build_str );
		scan.pfind( build_str, window.find_mode.matchcase );
		jnc retFalse;
		
		// we found the pattern...
		// find it's index and length.  esi = start, edi = end.
		// edi - esi = length
		// esi - hmem = index into buffer
		mov( esi, eax ); 
		sub( hmem, eax );
		add( eax, ft.chrg.cpMin );
		mov( ft.chrg.cpMin, fres );
		mov( edi, eax );
		sub( esi, eax );
		push( ft.chrg.cpMin );
		pop( ft.chrg.cpMax );
		add( eax, ft.chrg.cpMax );
		w.SendMessage( editebx.hred, w.EM_EXSETSEL, 0, &ft.chrg );
		//w.SendMessage( editebx.hred,w.EM_SCROLLCARET,0,0 );
		
		jmp done;
		
		retFalse:
			w.SendMessage( editebx.hred, w.EM_SETSEL, start_pos, end_pos );
			mov( 0, ft.chrg.cpMin );
			mov( -1, fres );
			
			
		done:
			if( hmem > 0 ) then
				mem.free( hmem );
			endif;
			mov( fres, eax );
				
		dbg.exits( "findPattern" );		
	end findPattern;
	
	getFindMode :procedure {@noframe};
	begin getFindMode;
		xor( eax, eax );
		if( window.find_mode.down ) then
			or( w.FR_DOWN, eax );
		endif;
		if( window.find_mode.matchcase ) then
			or( w.FR_MATCHCASE, eax );
		endif;
		if( window.find_mode.wholeword ) then
			or( w.FR_WHOLEWORD, eax );
		endif;
		ret();
	end getFindMode;

	Find :procedure( with_index:uns32 );
	
		// looks for selection
		// searches for text based on user settings
	
	begin Find;
		pushabi;
		dbg.put("find");
		mov( window.buffer_focus, ebx );
		w.SendMessage(editebx.hred, w.EM_EXGETSEL,0, &ft.chrg);
		
		if( window.find_mode.down ) then
			
			mov( ft.chrg.cpMax, eax );
			if( eax != ft.chrg.cpMin ) then
				// we have a selection already, don't try to find
				// currently selected text
				mov( eax, ft.chrg.cpMin );
			endif;
			
			mov( with_index, ft.chrg.cpMax );

		else

			mov( 0, ft.chrg.cpMax );

		endif;
		
		getFindMode();
		if( window.find_mode.matchpattern ) then
			
			findPattern( eax );
			
		else
			
			findNormal( eax );
			
		endif;
		popabi;
	end Find;

	expand_codes	:procedure( buf_addr:dword );
	begin expand_codes;
		//dbg.enters("expand_codes");
		pushad();
		mov( buf_addr, esi );
		mov( esi, edi );
		forever
			mov( [esi], al );
			breakif( !al );
			if( al = '\' ) then
				inc( esi );
				mov( [esi], al );
				breakif( !al );
				if( al = 'n' ) then
					mov( $0d, (type byte[edi] ));
					inc( esi );
				elseif( al = 't' ) then
					mov( $09, (type byte[edi] ));
					inc( esi );
				endif;
				inc( edi );
			else
				mov( al, [edi] );
				inc( esi );
				inc( edi );
			endif;
		endfor;
		mov( 0, (type byte[edi] ));
		dbg.dumpmem( buf_addr, 10 );
		popad();
		//dbg.exits("expand_codes");
	end expand_codes;


	Proc_Edit	:procedure( lParam:dword; wParam:dword; uMsg:uns32; hWin:dword );
	
		// this is the subclassed window procedure of the edit control
		// here we will intercept key messages and pass down only
		// the ones we want the edit control to receive.

	begin Proc_Edit;
		
		NOTE(Sevag:
			if we open any dialog while processing a key stroke
			set ctrl_down to false since the key_up
			message will be lost in the dialog's window proc)
		
		mov( window.buffer_focus, ebx );
		mov( uMsg, eax );
		switch( eax )

			case( w.WM_SYSKEYDOWN )
				dbg.put("syskey down =>", wParam );
				mov( wParam, eax );
				switch( eax )
			
					case( w.VK_MENU )
						// needed for alt + other modifiers
						mov( true, alt_down );
						
					case( w.VK_UP )
						command_move_line_up();
						jmp skip_proc;
						
					case( w.VK_DOWN )
						command_move_line_down();
						jmp skip_proc;
						
					case( w.VK_A )
						dbg.put("sys key + a :", w.VK_A);
						xor( eax, eax );
						jmp skip_proc;

				endswitch;
				
			case( w.WM_SYSCHAR )
				dbg.put("syschar =>", wParam );
				xor( eax, eax );
				jmp skip_proc;
				
			case( w.WM_SYSKEYUP )
				dbg.put("syskey up =>", wParam );
				mov( false, alt_down );
//bm=keycommands			
			case( w.WM_KEYDOWN )
				//dbg.put("key down =>", wParam );
				mov( wParam, eax );
				switch( eax )
				
					case( w.VK_SHIFT )
						mov( true, shift_down );

					case( w.VK_CONTROL )
						mov( true, ctrl_down );
						// we don't want the control key
						// going to rich edit
						jmp skip_proc;
					
					case( w.VK_INSERT )
						command_toggle_insert_mode();
					
					//>
					//case( w.VK_SLASH )
					//	mov( MODE_FIND, editebx.mode );
					//	Msg_Size( 0, 0, 0 );
					//	w.SetFocus( hedit );
					
					case( w.VK_W )
						if( ctrl_down ) then
							if( shift_down ) then
								command_copy_word();
							else
								command_delete_word();
							endif;
							jmp skip_proc;
						endif;
					
					case( w.VK_D )
						if( ctrl_down ) then
							inc( editebx.cursor.end_index );
							lea( eax, editebx.cursor );
							w.SendMessage( editebx.hred, w.EM_EXSETSEL, 0, eax );
							w.SendMessage( editebx.hred, w.EM_REPLACESEL,true, s_empty );
							jmp skip_proc;
						endif;
					
					case( w.VK_U )
						if( ctrl_down ) then
							if( shift_down ) then
								command_lowercase_selection();
							else
								command_uppercase_selection();
							endif;
							jmp skip_proc;
						endif;
						
					case( w.VK_E )
						if( ctrl_down ) then
							command_select_to_eol();
							w.SendMessage( editebx.hred, w.EM_REPLACESEL,true, s_empty );
							jmp skip_proc;
						endif;
					
					case( w.VK_BSLASH )
						if( ctrl_down ) then
							command_cut_line();
							jmp skip_proc;
						endif;
					
					case( w.VK_F )
						if( ctrl_down ) then
							Msg_Command( window.hwnd, IDM_FIND,0 );
							mov( false, ctrl_down );
							jmp skip_proc;
						endif;
					
					case( w.VK_G )
						if( ctrl_down ) then
							Msg_Command( window.hwnd, IDM_EDIT_GOTO,0 );
							mov( false, ctrl_down );
							jmp skip_proc;
						endif;
					
					case( w.VK_I )
						if( ctrl_down ) then
							xor( eax, eax );
							command_cursor_up();
							jmp skip_proc;
						endif;
					
					case( w.VK_UP )
						xor( eax, eax );
						command_cursor_up();
						jmp skip_proc;
						
					case( w.VK_DOWN )
						movzx( ctrl_down, eax );
						command_cursor_down();
						jmp skip_proc;
						
					case( w.VK_LEFT )
						movzx( ctrl_down, eax );
						command_cursor_left();
						jmp skip_proc;
						
					case( w.VK_RIGHT )
						movzx( ctrl_down, eax );
						command_cursor_right();
						jmp skip_proc;

					case( w.VK_J )
						if( ctrl_down ) then
							xor( eax, eax );
							command_cursor_left();
							jmp skip_proc;
						endif;
						
					case( w.VK_K )
						if( ctrl_down) then
							xor( eax, eax );
							command_cursor_down();
							jmp skip_proc;
						endif;

					case( w.VK_L )
						if( ctrl_down ) then
							xor( eax, eax );
							command_cursor_right();
							jmp skip_proc;
						endif;

					case( w.VK_LBRACKET )
						if( ctrl_down ) then
							command_move_to_bol();
							jmp skip_proc;
						endif;

					case( w.VK_RBRACKET )
						if( ctrl_down ) then
							command_move_to_eol();
							jmp skip_proc;
						endif;

					case( w.VK_N )
						if( ctrl_down ) then
							Msg_Command( window.hwnd, IDM_NEW, 0 );
							mov( false, ctrl_down );  
							jmp skip_proc;
						endif;

					case( w.VK_O )
						if( ctrl_down ) then
							Msg_Command( window.hwnd, IDM_OPEN,0 );
							mov( false, ctrl_down );
							jmp skip_proc;
						endif;	

					case( w.VK_S )
						if( ctrl_down ) then
							if( shift_down ) then
								Msg_Command( window.hwnd, IDM_SAVEAS,0 );
							else
								Msg_Command( window.hwnd, IDM_SAVE,0 );
							endif;
							mov( false, ctrl_down );
							jmp skip_proc;
						endif;
					
					case( w.VK_T )
						if( ctrl_down ) then
							Msg_Command( window.hwnd, IDM_PEG,0 );
							jmp skip_proc;
						endif;

					case( w.VK_F2 )
						Msg_Command( window.hwnd, IDM_AUTO,0 );
						mov( false, ctrl_down );
						jmp skip_proc;

					case( w.VK_F3 )
						if( ctrl_down ) then
							Msg_Command( window.hwnd, IDM_FINDPREV,0 );
						else
							Msg_Command( window.hwnd, IDM_FINDNEXT,0 );
						endif;
						jmp skip_proc;
						
					case( w.VK_F4 )
						Msg_Command( window.hwnd, IDM_WRAP,0 );
						jmp skip_proc;

					case( w.VK_F5 )
						mov( false, editebx.mark );
						if( shift_down ) then
							Msg_Command( window.hwnd, IDM_DATE, 0 );
						elseif( ctrl_down ) then
							Msg_Command( window.hwnd, IDM_TIME, 0 );
						else
							Msg_Command( window.hwnd, IDM_DATE_TIME, 0 );
						endif;
							
						jmp skip_proc;
						
					case( w.VK_F6 )
						Msg_Command( window.hwnd, IDM_READONLY,0 );
						jmp skip_proc;

					case( w.VK_COMMA )
						if( ctrl_down ) then
							movzx( ctrl_down, eax );
							command_cursor_left();
							jmp skip_proc;
						endif;
						
					case( w.VK_PERIOD )
						if( ctrl_down ) then
							movzx( ctrl_down, eax );
							command_cursor_right();
							jmp skip_proc;
						endif;

					case( w.VK_TAB )
						if( shift_down ) then
							if( ctrl_down ) then
								command_reduce_indent();							
							else
								command_increase_indent();
							endif;
							jmp skip_proc;
						
						elseif( config.readBool( s_settings, s_tabsasspace )) then
							w.SendMessage( editebx.hred, w.EM_REPLACESEL, true, strtabs );
							jmp skip_proc;
							
						else
							// it's a normal tab, let hred handle it
							mov( w.WM_CHAR, uMsg );
							mov( w.VK_TAB, wParam );
						endif;
					
					case( w.VK_RETURN )
						
						NOTE(Sevag:
							This isn't working properly if there
							is word wrap going on
						)
						
						// intercept the enter key
						// if shift-enter, then create empty line below and move cursor there
						// if ctrl-enter then create empty line above and move cursor there
						// we want to maintain auto indent features if possible. will
						// probably not work if new line is being created above the 1st line.
					
						if( ctrl_down ) then
							
							// check to see if we are on line 1
							if( editebx.line.number = 0 ) then
								command_move_to_bol();
								xor( eax, eax );
								clear_keystate();
								w.CallWindowProc(editebx.old_proc, hWin, uMsg, w.VK_RETURN, lParam );
								xor( eax, eax );
								command_cursor_up();
								jmp skip_proc;								
								
							else
								// open line above
								xor( eax, eax );
								command_cursor_up();
								getInfo();
								jmp do_shift;
							endif;
						
						elseif( shift_down ) then
							
							do_shift:
							mov( false, shift_down );
							//open line below
							// if we are not at eol, then move to eol
							mov( editebx.column_index, eax );
							if( editebx.line.length != eax ) then
								command_move_to_eol();
							endif;
						endif;
					
						mov( true, proc_return );
					
					case( w.VK_END )
						if( ! ctrl_down ) then
							if( shift_down ) then
								command_select_to_eol();
							else
								command_move_to_eol();
							endif;
							jmp skip_proc;
						endif;
						or( 1, eax );
						clear_keystate();
						w.CallWindowProc(editebx.old_proc, editebx.hred, w.WM_KEYDOWN, w.VK_END, 0 );
						jmp skip_proc;
						
					case( w.VK_HOME )
					
						if( !ctrl_down ) then
							command_move_to_bol();
							jmp skip_proc;
						endif;
						or( 1, eax );
						clear_keystate();
						w.CallWindowProc(editebx.old_proc, editebx.hred, w.WM_KEYDOWN, w.VK_HOME, 0 );
						jmp skip_proc;
					
					case( w.VK_SPACE )
						
						if( ctrl_down ) then
							
							command_toggle_mark();
							jmp skip_proc;
						endif;

					case( w.VK_ESCAPE )
						dbg.put("esc");
						w.SendMessage( window.hwnd, w.WM_CLOSE, 0, 0 );
						jmp skip_proc;

					default
						//dbg.put("reached default");

				endswitch;
				mov( false, editebx.mark ); // any other key will clear the selection.
			
			case( w.WM_KEYUP )
				
				//dbg.put("key up =>", wParam );
				mov( wParam, eax );
				switch( eax )
					case( w.VK_SHIFT )
						mov( false, shift_down );
						
					case( w.VK_CONTROL )
						mov( false, ctrl_down );
						jmp skip_proc;

					case( w.VK_RETURN )
						// a return was just processed in the edit control
						// do auto indent stuff
						dbg.put("return :", proc_return );
						if( proc_return ) then
							if( config.readBool( s_settings, s_autoindent ) ) then
	
								w.SendMessage( editebx.hred, w.EM_EXLINEFROMCHAR, 0, editebx.cursor.start_index);
								dec( eax );
								mov( szLINEBUFFER-1, (type word buffer[0]));
								w.SendMessage( editebx.hred, w.EM_GETLINE, eax, &buffer );
								if( eax ) then
									xor( ecx, ecx );
									while( eax ) do
										mov( buffer[ecx], dl );
										
										// counts the number of white spaces, either tabs or spaces
										if( dl == $09 || dl == ' ' ) then
											inc( ecx );
										else
											break;
										endif;
										dec( eax );
									endwhile;
									
									// if we are here, then ecx contains number of white space
									
									if( ecx ) then
										mov( 0, buffer[0] );
										if( config.readBool( s_settings, s_tabsasspace ) ) then
											mov( w.VK_SPACE, dl );
										else
											mov( w.VK_TAB, dl );
										endif;
										
										for( xor( eax, eax ); eax < ecx; inc( eax ) ) do
											mov( dl, buffer[eax] );
										endfor;
										mov( 0, buffer[eax] );
										w.SendMessage( editebx.hred, w.EM_REPLACESEL,true, &buffer );
										//w.SendMessage( editebx.hred, w.EM_SCROLLCARET,0,0);
									endif;
								endif;
							endif;
							mov( false, proc_return );
						endif;
				default
				endswitch;
				
			case( w.WM_CHAR )
				//dbg.put("char =>", wParam );
				
				mov( wParam, eax );
				if( ctrl_down || eax = w.VK_TAB || eax = w.VK_ESCAPE || eax = #$05 ) then
					jmp skip_proc;
				endif;
				
		endswitch;
			
		// pass control to the default edit window proc
		w.CallWindowProc(editebx.old_proc, hWin, uMsg, wParam, lParam );
		
		skip_proc:
			// jump here to prevent richedit processing the key press
		
	end Proc_Edit;

	Proc_FindDlg :procedure( lParam:dword; wParam:dword; uMsg:uns32; hWin:dword );
	
		// opens find dialog
		var
			cursor	:range;
			

	begin	Proc_FindDlg;
		pushabi;
		mov( uMsg, eax );
		mov( window.buffer_focus, ebx );
		if (eax = w.WM_INITDIALOG) then
			mov	(hWin, eax);
			mov	(eax,window.hfind);
			mov(0,fres);
			w.SendDlgItemMessage(hWin,IDC_FINDTEXT,w.EM_LIMITTEXT, @elements(findbuf)-1, 0);
			w.SendDlgItemMessage(hWin,IDC_FINDTEXT,w.WM_SETTEXT,0, &findbuf);
			
			w.SendDlgItemMessage(hWin,IDC_REPLACETEXT,w.EM_LIMITTEXT, @elements(replacebuf)-1, 0);
			w.SendDlgItemMessage(hWin,IDC_REPLACETEXT,w.WM_SETTEXT,0, &replacebuf);
			
			if( window.find_mode.matchcase ) then
				w.CheckDlgButton(hWin,IDC_CHK_MATCHCASE,w.BST_CHECKED);
			endif;
			
			if( window.find_mode.wholeword ) then
				w.CheckDlgButton(hWin,IDC_CHK_WHOLEWORD,w.BST_CHECKED);
			endif;
			
			if( window.find_mode.matchpattern ) then
				w.CheckDlgButton(hWin,IDC_CHK_PATTERN,w.BST_CHECKED);
			endif;
			
			if( window.find_mode.specialcodes ) then
				w.CheckDlgButton( hWin,IDC_CHK_SPECIAL, w.BST_CHECKED );
			endif;
			
			if( window.find_mode.down ) then
				mov( IDC_RBN_DOWN, edx );
			else
				mov( IDC_RBN_UP, edx );
			endif;
			w.CheckDlgButton(hWin, edx, w.BST_CHECKED);
				
		elseif (eax = w.WM_COMMAND) then
			mov	(wParam, eax);
			mov	(eax,edx);
			shr	(16,edx);
			and	($ffff,eax);
			if (edx = w.BN_CLICKED) then
				if(eax = w.IDOK) then
					if( window.find_mode.specialcodes ) then
						expand_codes( &findbuf );
					endif;
					Find( MINUS_ONE );
					w.SetFocus(window.hfind);
					
				elseif( eax = w.IDCANCEL ) then
					w.SendMessage( hWin, w.WM_CLOSE, NULL, NULL );
					
				elseif( eax = IDC_BTN_REPLACE ) then
					if( window.find_mode.specialcodes ) then
						expand_codes( &findbuf );
						expand_codes( &replacebuf );
					endif;
					if( fres!=-1 ) then
						w.SendMessage( editebx.hred, w.EM_EXGETSEL, 0, &ft.chrg );
						w.SendMessage( editebx.hred, w.EM_REPLACESEL, true, &replacebuf );
						zstr.len( &replacebuf );
						add( eax, ft.chrg.cpMin );
						mov( ft.chrg.cpMin, eax );
						mov( eax, ft.chrg.cpMax );
						w.SendMessage( editebx.hred, w.EM_EXSETSEL, 0, &ft.chrg );
					endif;
					Find( MINUS_ONE );
					w.SetFocus( window.hfind );
	
				elseif( eax = IDC_BTN_REPLACEALL ) then
					mov( true, window.find_mode.down );
					push( editebx.cursor.start_index );
					//lea( eax, editebx.cursor );
					//w.SendMessage( editebx.hred, w.EM_EXGETSEL, 0, eax );
					w.LockWindowUpdate( editebx.hred );
					//w.SendMessage( editebx.hred, w.EM_SETSEL, editebx.cursor.start_index, editebx.cursor.start_index );
					w.SendMessage( editebx.hred, w.EM_SETSEL, 0, 0 );
					Find( MINUS_ONE );
					while (fres!=-1) do
						w.SendMessage( hWin, w.WM_COMMAND, IDC_BTN_REPLACE, 0 );
					endwhile;
					pop( editebx.cursor.start_index );
					w.SendMessage( editebx.hred, w.EM_SETSEL, editebx.cursor.start_index, editebx.cursor.start_index );
					w.LockWindowUpdate( NULL );
					w.SetFocus( window.hfind );
					
				elseif( eax = IDC_BTN_REPLACESEL ) then
					if( window.find_mode.specialcodes ) then
						expand_codes( &findbuf );
						expand_codes( &replacebuf );
					endif;
					mov( true, window.find_mode.down );
					push( editebx.cursor.start_index );
					lea( esi, cursor );
					w.SendMessage( editebx.hred, w.EM_EXGETSEL, 0, esi );
					w.LockWindowUpdate( editebx.hred );
					w.SendMessage( editebx.hred, w.EM_SETSEL, cursor.start_index, cursor.start_index );
					Find( cursor.end_index );
					while (fres!=-1) do
						w.SendMessage( editebx.hred, w.EM_EXGETSEL, 0, &ft.chrg );
						dbg.put("found, replacing with :");
						dbg.putz( &replacebuf );
						w.SendMessage( editebx.hred, w.EM_REPLACESEL, true, &replacebuf );
						Find( cursor.end_index );
					endwhile;
					pop( editebx.cursor.start_index );
					w.SendMessage( editebx.hred, w.EM_SETSEL, editebx.cursor.start_index, editebx.cursor.start_index );
					//w.SendMessage( editebx.hred, w.EM_SCROLLCARET, 0, 0 );
					w.LockWindowUpdate( NULL );
					w.SetFocus( window.hfind );
					
				elseif (eax = IDC_RBN_DOWN) then
					mov( true, window.find_mode.down );
					mov	(-1,fres);
					
				elseif (eax = IDC_RBN_UP) then
					mov( false, window.find_mode.down );
					mov( false, window.find_mode.matchpattern );
					w.CheckDlgButton( hWin, IDC_CHK_PATTERN, w.BST_UNCHECKED );
					mov	(-1, fres);
					
				elseif (eax = IDC_CHK_MATCHCASE) then
					w.IsDlgButtonChecked(hWin, IDC_CHK_MATCHCASE);
					if (eax) then
						mov( true, window.find_mode.matchcase );
					else
						mov( false, window.find_mode.matchcase );
					endif;
					mov	(-1, fres);
					
				elseif (eax = IDC_CHK_WHOLEWORD) then
					w.IsDlgButtonChecked(hWin, IDC_CHK_WHOLEWORD);
					if (eax) then
						mov( true, window.find_mode.wholeword );
						mov( false, window.find_mode.matchpattern );
						w.CheckDlgButton( hWin, IDC_CHK_PATTERN, w.BST_UNCHECKED );
					else
						mov( false, window.find_mode.wholeword );
					endif;
					mov	(-1,fres);
					
				elseif( eax = IDC_CHK_PATTERN ) then
					w.IsDlgButtonChecked( hWin, IDC_CHK_PATTERN );
					if (eax) then
						
						mov( false, window.find_mode.wholeword );
						mov( true, window.find_mode.matchpattern );
						w.CheckDlgButton( hWin, IDC_CHK_WHOLEWORD, w.BST_UNCHECKED );
						w.CheckRadioButton( hWin, IDC_RBN_DOWN, IDC_RBN_UP, IDC_RBN_DOWN );
					else
						mov( false, window.find_mode.matchpattern );
					endif;
					mov	(-1,fres);
					
				elseif( eax = IDC_CHK_SPECIAL ) then
					w.IsDlgButtonChecked( hWin, IDC_CHK_SPECIAL );
					if( eax ) then
						mov( true, window.find_mode.specialcodes );
					else
						mov( false, window.find_mode.specialcodes );
					endif;
				endif;
				
			elseif( edx = w.EN_UPDATE ) then
	
				push( ebx );
				mov( eax, ebx );
				if( w.SendDlgItemMessage(hWin, ebx, w.EM_GETMODIFY, 0, 0 )) then
	
					if (ebx = IDC_FINDTEXT) then
	
						w.SendDlgItemMessage(hWin, ebx, w.WM_GETTEXT, @elements(findbuf)-1, &findbuf);
						mov	(-1, fres);
						
						if( ! w.IsDlgButtonChecked( hWin, IDC_CHK_PATTERN ) &&
							! w.IsDlgButtonChecked( hWin, IDC_CHK_SPECIAL )) then
							
							// incremental find only works in normal mode
							// since special and pattern mode require special parsing
							
							getFindMode();
							findNormal( eax );
							if( fres != -1 ) then
								updateStatus();
							endif;
						endif;

						
					elseif( ebx = IDC_REPLACETEXT) then
						w.SendDlgItemMessage(hWin, ebx, w.WM_GETTEXT, @elements(replacebuf)-1, &replacebuf);
						mov	(-1, fres);
						
					endif;
					
					w.SendDlgItemMessage( hWin, ebx, w.EM_SETMODIFY, false, 0 );
				endif;
				
				pop( ebx );
	
			endif;
			
		elseif (eax = w.WM_ACTIVATE) then
			w.SetFocus( window.hfind );
	
		elseif (eax = w.WM_CLOSE) then
			w.DestroyWindow(window.hfind);
			mov	(0,window.hfind);
			w.SetFocus(editebx.hred);
		else
			mov	(false, eax);
			popabi;
			exit Proc_FindDlg;
		endif;
		mov	(true, eax);
		popabi;
	end Proc_FindDlg;

	getConfigPath :procedure( s:string );
	
		// locates the configuration file
		var
			default_config	:string;
			find_config		:string; 
	
	begin getConfigPath;
		
		mov( str.talloc( w.MAX_PATH ), default_config );
		mov( str.talloc( w.MAX_PATH ), find_config );
		
		
		// look for config at default location, which is SavageEd folder
		w.GetModuleFileName (window.hinst, &buffer, @size(buffer) );
		str.cpyz( &buffer, default_config );
		filesys.extractPath( default_config, default_config );
		str.put2( default_config, '\', config_file );
		if( filesys.exists( default_config )) then
			
			// we found config in SavageEd home folder, means the user
			// wants to use a local configuration file.
			str.cpy( default_config, s );
		else
			
			// no default config file, look for one in %USERPROFILE%\config\
			w.ExpandEnvironmentStrings( "%USERPROFILE%", &buffer, szLINEBUFFER );
			str.cpyz( &buffer, find_config ); 
			str.put2( find_config, "\config\", config_file );

			if( filesys.exists( find_config )) then
				
				// we found a profile in the user folder
				str.cpy( find_config, s );
			
			else
				
				// there is no config file, use default
				str.cpy( default_config, s );
				
			endif;
			
		endif;
		
	end getConfigPath;


	initConfig	:procedure;
	
	/*
		Look for SavageEd.ini file:
			Look in current folder, if found, use that one.
			else, look in %USERPROFILE%\config\, if found, use that one.
			else, create a new one in the current folder.
		
		read settings from config file
		expand this as more settings are added
	*/
	
		var
			config_path	:string;
			build_str	:string;
			
	
	begin initConfig;
	dbg.enters("initConfig");
		
		mov( str.talloc(400), config_path );
		mov( str.talloc(1000), build_str );
		str.cpy( s_empty, default_extension );
		mov( str.alloc( 500 ), input.return );
		mov( str.alloc( 500 ), input.initial);
		getConfigPath( config_path );
		if( filesys.exists( config_path ) ) then
			
			// set default find mode
			mov( false, window.find_mode.down );
			mov( false, window.find_mode.wholeword );
			mov( false, window.find_mode.matchcase );
			mov( false, window.find_mode.matchpattern );
			
			// config file exists, read it and
			// apply settings as per file.
			config.create_file( config_path );
			config.readUns( s_window, "xPos" );
			mov( eax,window.xPos );

			config.readUns( s_window, "yPos" );
			mov( eax,window.yPos );
			config.readUns( s_window, "width" );
			mov( eax,window.width );
			config.readUns( s_window, "height" );
			mov( eax,window.height );
			
			
			config.readInt( s_font, "Height" );
			mov( eax, logfont.lfHeight );
			config.readInt( s_font, "Width" );
			mov( eax, logfont.lfWidth );
			config.readInt( s_font, "Weight" );
			mov( eax, logfont.lfWeight );
			str.cpyz (&logfont.lfFaceName, build_str );
			
			config.readString( s_font, "Name", build_str );
			zstr.cpy( (type zstring build_str ), &logfont.lfFaceName );
			
			config.readInt( s_font, "Italic");
			mov( al, logfont.lfItalic);
			config.readInt( s_font, "Pitch" );			
			mov( al, logfont.lfPitchAndFamily);
			config.readHex( s_text, s_background_color);
			mov( eax, window.backColor );
			config.readHex( s_text, s_text_color);
			mov( eax, window.textColor );
			
			config.readString( s_settings, "Line Break", build_str );
			if( str.eq( build_str, s_lf )) then
				mov( LF, window.line_break );
			else
				mov( CRLF, window.line_break );
			endif;

			config.readBin( s_text, s_custcolors, &customColors, @size( customColors ) );
			config.readBin( s_text, s_find, &window.find_mode, @size( window.find_mode ) );
			
			if( config.readString(s_settings, "Default Extension", build_str )) then
				str.cpy( build_str, default_extension );
			endif;
			
			mov( window.buffer_focus, ebx );
			if( editebx.hred ) then
				if( config.readBool( s_settings, "Active URL" )) then
					w.SendMessage( editebx.hred, w.EM_AUTOURLDETECT, true, NULL);
					w.SendMessage( editebx.hred, w.EM_SETEVENTMASK, 0, w.ENM_SELCHANGE | w.ENM_MOUSEEVENTS | w.ENM_LINK);
				else
					w.SendMessage( editebx.hred, w.EM_AUTOURLDETECT, false, NULL);
					w.SendMessage( editebx.hred, w.EM_SETEVENTMASK, 0, w.ENM_SELCHANGE | w.ENM_MOUSEEVENTS );
				endif;
				
				setFormat();
			endif;
			
		else
			// no file exists, create one
			// and set up with default settings.
			
			config.create();
			config.writeUns( s_settings, s_tabs, DEFAULT_TAB_STOP );
			config.writeString( s_settings, "Line Break", s_crlf );

			config.writeBool( s_settings, "Active URL", false );
			config.writeString( s_settings, "Date Format", default_date_format );
			config.writeString( s_settings, "Time Format", default_time_format );
			config.writeString( s_settings, "Default Extension", default_extension );

			// some hard coded defaults
			mov( 10,window.xPos );
			mov( 10,window.yPos );
			mov( 640,window.width );
			mov( 400,window.height );
			
			mov( color_white, window.backColor);
			mov( color_black, window.textColor);
			config.writeHex( s_text, s_background_color, window.backColor);
			config.writeHex( s_text, s_text_color, window.textColor);

			
			// get default font
			zstr.cpy( (type zstring s_fontname ), &logfont.lfFaceName );
			config.writeString( s_font, "Name", s_fontname );
			mov( -12, logfont.lfHeight );
			mov( 400, logfont.lfWeight );
			mov( 0, logfont.lfItalic );
			mov( 49, logfont.lfPitchAndFamily );
			mov( 400, logfont.lfWeight );
			

			config.writeInt( s_font, "Height", logfont.lfHeight );
			config.writeInt( s_font, "Width", logfont.lfWidth );
			config.writeInt( s_font, "Weight", logfont.lfWeight );
			
			movzx( logfont.lfItalic, eax );
			config.writeInt( s_font, "Italic", eax );
			movzx( logfont.lfPitchAndFamily, eax );
			config.writeInt( s_font, "Pitch", eax );
			
			config.writeFileName( config_path );
			
		endif;
		
		w.CreateFontIndirect( &logfont );
		mov( eax, window.hfont );
		
	dbg.exits("initConfig");
	end initConfig;

	updateStatus :procedure;
		
		// update the status bar
		// called every time a key up message is processed
		// or when the status bar needs to be updated
		var
			build_str	:string;
			
			
	begin updateStatus;
		
		mov( str.talloc( 1000 ), build_str );
		getInfo();
		mov( window.buffer_focus, ebx );
		mov( editebx.line.number, eax );
		inc( eax );
		mov( editebx.column_index, ecx );
		inc( ecx );
		mov( editebx.cursor.end_index, edx );
		sub( editebx.cursor.start_index, edx );
		if( (type int32 edx ) < 0 ) then
			neg( edx );
		endif;
		str.put( build_str, "Line: ", (type uns32 eax ), " / ", editebx.lines,
				 "    Col: ", (type uns32 ecx ), "    Pos: ", editebx.cursor.start_index,
				 "    Sel: ", (type uns32 edx ) );
				
		w.SendMessage( window.hstatus, w.SB_SETTEXT, 0, build_str );
		

		if( config.readBool( s_settings, s_readonly )) then
			w.SendMessage( window.hstatus, w.SB_SETTEXT, 1, s_r );
		else
			w.SendMessage( window.hstatus, w.SB_SETTEXT, 1, s_b );
		endif;
				
		if( editebx.mark ) then
			w.SendMessage( window.hstatus, w.SB_SETTEXT, 2, s_mark );	
		else
			w.SendMessage( window.hstatus, w.SB_SETTEXT, 2, s_b );
		endif;
		

		if( config.readBool( s_settings, s_autosave ) ) then
			w.SendMessage( window.hstatus, w.SB_SETTEXT, 3, s_auto );
		else
				w.SendMessage( window.hstatus, w.SB_SETTEXT, 3, s_b );
		endif;
		
		str.cpy( s_b, build_str );
		config.readString( s_settings, "Line Break", build_str );
		w.SendMessage( window.hstatus, w.SB_SETTEXT, 4, build_str );
		
		movzx( editebx.mode, eax );
		switch( eax )
				
			case( MODE_EDITINI )
				str.put( build_str, "Mode :Edit Configuration" );

			case( MODE_VIEWDOCS )
				str.put( build_str, "Mode :View Documentation" );
			
			case( MODE_INSERT )
				str.put( build_str, "Mode :Insert" );

			case( MODE_OVER )
				str.put( build_str, "Mode :Overwrite" );
				
		endswitch;
		w.SendMessage( window.hstatus, w.SB_SETTEXT, 5, build_str);
		// window title may have changed somewhere along the line, update it
		setWindowTitle();
		
	end updateStatus;

	setTabWidth :procedure { @noframe, @returns("EAX") };
	
		// opens dialog to set tab width
	
	begin setTabWidth;
		
		config.readUns( s_settings, s_tabs );
		dbg.put("tabs :", eax );
		str.put( input.initial, (type uns32 eax) ); 
		w.DialogBoxParam( window.hinst, val ID_INPUT, window.hwnd, &Proc_Input, s_inputtab );
		if( return > 0 ) then
			try
				conv.strTou32( input.return, 0 );
				
			anyexception
				xor( eax, eax );
			endtry;
		else
			xor( eax, eax );
		endif;
		ret();
	end setTabWidth;

	getLineInfo :procedure(var line:LineInfo);
		
		// input expects a LineInfo structure with the
		// .line field containing the desired line information
		// will fill the rest of the structure.
		// returns 0 if no line is available
		
	begin getLineInfo;
		USE( EBX, EDI );
		mov( line, ebx );
		mov( window.buffer_focus, edi );
		w.SendMessage( editedi.hred, w.EM_LINEINDEX, (type LineInfo [ebx]).number, 0 );
		if( (type int32 eax) >= 0 ) then
			mov( eax, (type LineInfo[ebx]).index );

			w.SendMessage( editedi.hred, w.EM_LINELENGTH, eax, 0 );
			mov( eax, (type LineInfo[ebx]).length );
		else
			xor( eax, eax );
		endif;
		ENDUSE;
	end getLineInfo;

	getInfo: procedure;
	
		// collects informaiton about the edit state
		// and stores it in the info structure
		var	index	:uns32;
	
	begin getInfo;
		//dbg.enters("getInfo");
		push( edi );
		push( esi );
		mov( 0, index );
		mov( window.buffer_focus, edi );
		lea( esi, editedi.cursor );
		w.SendMessage( editedi.hred, w.EM_EXGETSEL, 0, esi );

		// if mark is set, find the relative direction
		if( editedi.mark ) then
			mov( editedi.mark_point, eax );
			if( editedi.cursor.start_index = eax ) then
				dbg.put("using tail index");
				mov( editedi.cursor.end_index, index );
			else
				dbg.put("using head index");
				mov( editedi.cursor.start_index, index );
			endif;
		else
			mov( editedi.cursor.start_index, index );
		endif;
			
		w.SendMessage( editedi.hred, w.EM_EXLINEFROMCHAR, 0, index );
		mov( eax, editedi.line.number );
		getLineInfo(editedi.line);
		mov( index, eax );
		sub( editedi.line.index, eax );
		mov( eax, editedi.column_index );
		w.SendMessage( editedi.hred, w.EM_GETLINECOUNT, 0, 0 );
		mov( eax, editedi.lines );

		pop( esi );
		pop( edi );
		//dbg.exits("getInfo");
	end getInfo;

	command_toggle_insert_mode	:procedure {@noframe};
	begin command_toggle_insert_mode;
		mov( window.buffer_focus, ebx );
		if( editebx.mode = MODE_INSERT ) then
			mov( MODE_OVER, editebx.mode );
		elseif( editebx.mode = MODE_OVER ) then
			mov( MODE_INSERT, editebx.mode );
		endif;
		updateStatus();
		ret();
	end command_toggle_insert_mode;


	clear_keystate	:procedure {@noframe};
		
		// on entry, eax will contain state of control key
		// 0 = up, 1 = down
	
	begin clear_keystate;
		push( eax );
		mov( window.buffer_focus, ebx );
		mem2.fillMem( &keystate, @elements( keystate ), 0 );
		if( editebx.mark || shift_down ) then
			mov( -1, keystate[w.VK_SHIFT] );
		endif;
		pop( eax );
		if( eax ) then
			dbg.put("setting control down");
			mov( -1, keystate[w.VK_CONTROL] );
		endif;
		w.SetKeyboardState( &keystate );
		ret();
	end clear_keystate;

//bm=editcommands

	command_selection_to_string	:procedure;
	
		var
			sel_string	:string;
			txt_range	:w.TEXTRANGE;
	
	begin command_selection_to_string;
		
		push( edi );
		mov( window.buffer_focus, edi );
		mov( editedi.cursor.end_index, eax );
		sub( editedi.cursor.start_index, eax );
		//dbg.put("str size = ", eax );
		str.alloc( eax );
		mov( eax, sel_string );
		push( (type str.strRec[eax]).maxlen );
		pop( (type str.strRec[eax]).length );
		mov( eax, txt_range.lpstrText );
		lea( esi, txt_range );
		w.SendMessage( editedi.hred, w.EM_EXGETSEL, 0, esi );
		w.SendMessage( editedi.hred, w.EM_GETTEXTRANGE, 0, esi );
		pop( edi );
		mov( sel_string, eax );

	end command_selection_to_string;

	command_lowercase_selection	:procedure;
		var
			start_index	:dword;
			end_index	:dword;
	begin command_lowercase_selection;
		pushad();
		getInfo();
		mov( window.buffer_focus, ebx );
		mov( editebx.cursor.start_index, eax );
		mov( eax, start_index );
		mov( editebx.cursor.end_index, end_index );

		if( eax = editebx.cursor.end_index ) then
			inc( editebx.cursor.end_index );
			w.SendMessage( editebx.hred, w.EM_SETSEL, editebx.cursor.start_index, editebx.cursor.end_index );	
		endif;
		command_selection_to_string();
		mov( eax, esi );
		str.lower1( esi );
		w.SendMessage( editebx.hred, w.EM_REPLACESEL, true, esi );
		str.free( esi );
		w.SendMessage( editebx.hred, w.EM_SETSEL, start_index, end_index );
		popad();
	end command_lowercase_selection;

	command_uppercase_selection	:procedure;
		var
			start_index	:dword;
			end_index	:dword;
			
	begin command_uppercase_selection;
		pushad();
		getInfo();
		mov( window.buffer_focus, ebx );
		mov( editebx.cursor.start_index, eax );
		mov( eax, start_index );
		mov( editebx.cursor.end_index, end_index );
		if( eax = editebx.cursor.end_index ) then
			inc( editebx.cursor.end_index );
			w.SendMessage( editebx.hred, w.EM_SETSEL, editebx.cursor.start_index, editebx.cursor.end_index );	
		endif;
		command_selection_to_string();
		mov( eax, esi );
		str.upper1( esi );
		w.SendMessage( editebx.hred, w.EM_REPLACESEL, true, esi );
		str.free( esi );
		w.SendMessage( editebx.hred, w.EM_SETSEL, start_index, end_index );
		popad();
	end command_uppercase_selection;

	command_edit_ini	:procedure;
		
		// Load the configuration file and allow editing
		// set mode flag to inidcate ini file is being edited
		// this mode flag should be intercepted by the save file
		// command to reload the ini.
		
		// make sure we have already gotten confirmation to save any
		// existing work before calling this function
			
		
	begin command_edit_ini;
		
		TODO( "when multi buffers are implemented, this should open a new buffer" )
		
		USE( EBX );
		mov( window.buffer_focus, ebx );
		str.cpy( config.fileName, editebx.filepath );
		str.rmvLastChar1( config.fileName );
		str.put2( config.fileName, "~" );
		config.writeFile();
		str.rmvLastChar1( config.fileName );
		str.put2( config.fileName, "i" );

		str.cpy( config.fileName, editebx.filepath );
		
		loadFile( editebx.filepath );
		mov( MODE_EDITINI, editebx.mode );
		updateStatus();
		ENDUSE;
	end command_edit_ini;

	command_display_manual	:procedure { @noframe };
		
		// load the SavageEd.md which is saved as a
		// resource in SavageEd.exe
	
		// opens the manual in a new instance of SavageEd
		
	begin command_display_manual;
		
		if( w.FindResource(window.hinst, val ID_SAVAGEED_MANUAL, val w.RT_RCDATA ) ) then
			
			TODO( "when multi buffers are implemented, this should open a new buffer" )
			
			if( w.LoadResource(window.hinst, eax ) ) then
				mov( window.buffer_focus, ebx );
				w.SendMessage( editebx.hred, w.WM_SETTEXT, 0, eax );
				str.cpy( s_document, editebx.filepath );
				mov( MODE_VIEWDOCS, editebx.mode );
				updateStatus();
				w.SetFocus( editebx.hred );
				
			else
				
				jmp _error;	
				
			endif;
			
		else
			_error:
			Error("Couldn't Load Resource, file may be corrupted.", true);
			
			
		endif;
		ret();	

	end command_display_manual;

	command_get_line	:procedure( var line_buffer:dword );
		
		// copy the current line in the editor to buffer
		
	begin command_get_line;
		mov( line_buffer, eax );
		mov( szLINEBUFFER, (type word [eax] ) );
		mov( window.buffer_focus, esi );
		w.SendMessage( editesi.hred, w.EM_GETLINE, editesi.line.number, eax );
		// returns length of line copied in eax
	end command_get_line;

	command_get_word	:procedure {@noframe };
	
		// returns the start and end of a word
		// in buffer_focus.cursor.start_index and buffer_focus.cursor.end_index
	
	begin command_get_word;
		dbg.enters( "command_get_word" );
		USE( EDX, EBX )
		command_get_line( &buffer );
		dbg.putz( &buffer);
		// if we are sitting on a space, newline or tab char, don't do anything
		mov( &buffer, edx );
		mov( window.buffer_focus, ebx );
		add( editebx.column_index, edx );
		
		if( (type byte[edx]) = ' ' || (type byte[edx]) = $09 ||
		    (type byte[edx]) = $0a ) then
			xor( eax, eax );
			jmp done;
		endif;
		
		// find start index of word
		// any white space, single quotee or double quote marks word boundries 
		if( edx > &buffer ) then
			forever
				dec( edx );
				breakif( edx < &buffer );
				dbg.put("edx = ", (type char [edx]), ":", (type byte[edx]));
				if( ((type byte [edx]) = ' ') ||
					((type byte[edx]) = $09) ||
					((type byte[edx]) = '"') ||
					((type byte[edx]) = '''' ) ) then
					inc( edx );
					break;
				endif;
			endfor;
		endif;
		
		// change buffer coordinate to buffer_focus.hred coordinate
		sub( &buffer, edx );
		add( editebx.line.index, edx );
		mov( edx, editebx.cursor.start_index);
		
		// find end index of word
		mov( &buffer, edx );
		add( editebx.column_index, edx );
		forever
			inc( edx );
			breakif( (type byte[edx]) = 0 );
			breakif( (type byte[edx]) = $0d ||
					 (type byte[edx]) = $0a ||
					 (type byte[edx]) = '"' ||
					 (type byte[edx]) = ''''||
					 (type byte[edx]) = ' ' ||
					 (type byte[edx]) = $09 );
			
		endfor;

		// change buffer coordinate to buffer_focus.hred coordinate
		sub( &buffer, edx );
		add( editebx.line.index, edx );
		dbg.put("end index :", (type uns32 edx));
		mov( edx, editebx.cursor.end_index );
		
		or( 1, eax );
				
	done:
		ENDUSE;
		dbg.exits( "command_get_word" );
		ret();
	end command_get_word;

	command_delete_word	:procedure {@noframe};
	
		// delete the word under the cursor
		
	begin command_delete_word;
		mov( window.buffer_focus, ebx );
		if( command_get_word() ) then
			lea( eax, editebx.cursor );
			w.SendMessage( editebx.hred, w.EM_EXSETSEL, 0, eax );
			w.SendMessage( editebx.hred, w.EM_REPLACESEL, true, s_empty );
		endif;
		ret();
	end command_delete_word;

	command_copy_word :procedure {@noframe};
	begin command_copy_word;
		if( command_get_word() ) then
			mov( window.buffer_focus, ebx );
			lea( eax, editebx.cursor );
			w.SendMessage( editebx.hred, w.EM_EXSETSEL, 0, eax );
			w.SendMessage(editebx.hred, w.WM_COPY,0,0);			
		endif;
		ret();
	end command_copy_word;

	command_select_all :procedure {@noframe};
	begin command_select_all;
		mov( window.buffer_focus, ebx );
		lea( eax, editebx.cursor );
		mov	(0, editebx.cursor.end_index);
		mov	(-1, editebx.cursor.start_index);
		w.SendMessage( editebx.hred, w.EM_EXSETSEL, 0, eax );
		ret();		
	end command_select_all;

	command_cut_line	:procedure {@noframe};
	begin command_cut_line;
		mov( window.buffer_focus, ebx );
		mov( editebx.line.index, eax );
		mov( eax, editebx.cursor.start_index );
		add( editebx.line.length, eax );
		inc( eax ); // consume carriage return
		mov( eax, editebx.cursor.end_index );
		lea( eax, editebx.cursor );
		w.SendMessage( editebx.hred, w.EM_EXSETSEL, 0, eax );
		w.SendMessage(editebx.hred, w.WM_CUT,0,0);
		ret();
	end command_cut_line;

	command_cursor_up	:procedure {@noframe};
		// on entry, eax will contain desired state of control key
		// 0 = up, 1 = down
	begin command_cursor_up;
		mov( window.buffer_focus, ebx );
		if( editebx.line.index > 0 ) then
			clear_keystate();
			w.CallWindowProc(editebx.old_proc, editebx.hred, w.WM_KEYDOWN, w.VK_UP, 0 );
		endif;
		ret();
	end command_cursor_up;

	command_cursor_down	:procedure {@noframe};
		// on entry, eax will contain desired state of control key
		// 0 = up, 1 = down
	begin command_cursor_down;
		mov( window.buffer_focus, ebx );
		mov( editebx.line.number, ecx );
		inc( ecx );
		if( ecx = editebx.lines ) then
			jmp _done;
		endif;
		clear_keystate();
		w.CallWindowProc(editebx.old_proc, editebx.hred, w.WM_KEYDOWN, w.VK_DOWN, 0 );
		_done:
		ret();
	end command_cursor_down;

	command_cursor_left	:procedure {@noframe};
		// on entry, eax will contain desired state of control key
		// 0 = up, 1 = down
	begin command_cursor_left;
		mov( window.buffer_focus, ebx );
		mov( eax, ecx );
		if( editebx.line.index = 0 && editebx.column_index = 0 ) then
			jmp _done;
		endif;
		mov( ecx, eax );
		clear_keystate();

		w.CallWindowProc( editebx.old_proc, editebx.hred, w.WM_KEYDOWN, w.VK_LEFT, 0 );
		
		_done:
		ret();
	end command_cursor_left;

	command_cursor_right	:procedure {@noframe};
		// on entry, eax will contain desired state of control key
		// 0 = up, 1 = down
	begin command_cursor_right;
		mov( window.buffer_focus, ebx );
		mov( editebx.line.number, ecx );
		inc( ecx );
		mov( editebx.column_index, edx );
		if( ecx = editebx.lines && edx = editebx.line.length ) then
			jmp _done;
		endif;
		clear_keystate();
		w.CallWindowProc(editebx.old_proc, editebx.hred, w.WM_KEYDOWN, w.VK_RIGHT, 0 );
		_done:
		ret();
	end command_cursor_right;

	command_move_to_bol	:procedure {@noframe};
	begin command_move_to_bol;
		mov( window.buffer_focus, ebx );
		mov( editebx.line.index, eax );
		if( editebx.line.index = 0 && editebx.column_index = 0 ) then
			jmp done;
		endif;

		if( editebx.column_index = 0 ) then
			// we're at the beginning of line, go to the beginning of prev line.
			command_cursor_left();
			if( editebx.column_index > 0 ) then
				jmp _home;
			endif;
		else
			_home:
			xor( eax, eax );
			clear_keystate();
			w.CallWindowProc(editebx.old_proc, editebx.hred, w.WM_KEYDOWN, w.VK_HOME, 0 );
		endif;
		done:
		dbg.exits("command_move_to_bol");
		ret();
	end command_move_to_bol;

	command_move_to_eol	:procedure;
	begin command_move_to_eol;
		dbg.enters("command_move_to_eol");
		mov( window.buffer_focus, ebx );
		mov( editebx.column_index, eax );
		if( eax = editebx.line.length || ! eax ) then
			command_cursor_right();
			mov( editebx.line.length, eax );
			if( eax && eax != editebx.column_index )then
				jmp _callit;
			endif;
		else
			_callit:
			xor( eax, eax );
			clear_keystate();
			w.CallWindowProc( editebx.old_proc, editebx.hred, w.WM_KEYDOWN, w.VK_END, 0 );
		endif;
		dbg.exits("command_move_to_eol");
	end command_move_to_eol;

	command_move_line_up :procedure {@noframe};
	begin command_move_line_up;
		dbg.enters( "command_move_line_up" );
		mov( window.buffer_focus, ebx );
		if( editebx.line.number > 0 ) then
			push( editebx.column_index );
			command_get_line( &buffer );
			mov( editebx.line.length, eax );
			add( editebx.line.index, eax );
			inc( eax ); // get the line feed
			w.SendMessage( editebx.hred, w.EM_SETSEL, editebx.line.index, eax );
			w.SendMessage( editebx.hred, w.EM_REPLACESEL, true, s_empty );
			command_move_to_bol();
			w.SendMessage( editebx.hred, w.EM_REPLACESEL, true, &buffer );
			getInfo();
			command_move_to_bol();
			pop( eax );
			add( editebx.line.index, eax );
			w.SendMessage( editebx.hred, w.EM_SETSEL, eax, eax );
		endif;
		
		dbg.exits( "command_move_line_up" );
		ret();
	end command_move_line_up;

	command_move_line_down :procedure {@noframe};
	begin command_move_line_down;
		dbg.enters( "command_move_line_down" );
		mov( window.buffer_focus, ebx );
		mov( editebx.lines, eax );
		if( editebx.line.number < eax ) then
			push( editebx.column_index );
			command_get_line( &buffer );
			mov( editebx.line.length, eax );
			add( editebx.line.index, eax );
			inc( eax ); // get the line feed
			w.SendMessage( editebx.hred, w.EM_SETSEL, editebx.line.index, eax );
			w.SendMessage( editebx.hred, w.EM_REPLACESEL, true, s_empty );
			command_cursor_down();
			w.SendMessage( editebx.hred, w.EM_REPLACESEL, true, &buffer );
			getInfo();
			command_move_to_bol();
			pop( eax );
			add( editebx.line.index, eax );
			w.SendMessage( editebx.hred, w.EM_SETSEL, eax, eax );
		endif;
		dbg.exits( "command_move_line_down" );
		ret();
	end command_move_line_down;

	command_select_to_eol :procedure {@noframe};
	begin command_select_to_eol;
		USE( EBX );
		mov( window.buffer_focus, ebx );
		mov( editebx.line.length, eax );
		add( editebx.line.index, eax );
		w.SendMessage( editebx.hred, w.EM_SETSEL, editebx.cursor.start_index, eax );
		ENDUSE;
		ret();
	end command_select_to_eol;

	command_toggle_mark :procedure {@noframe};
	begin command_toggle_mark;
		dbg.put("toggle_mark");
		// toggle mark
		mov( window.buffer_focus, ebx );
		if( editebx.mark ) then
			mov( false, editebx.mark );
			mov( 0, editebx.mark_point );
		else
			mov( true, editebx.mark );
			mov( editebx.cursor.start_index, editebx.mark_point );
		endif;
		updateStatus();
		ret();
	end command_toggle_mark;

	command_toggle_readonly :procedure {@noframe};
	begin command_toggle_readonly;
		push( ecx );
		if( config.readBool( s_settings, s_readonly ) ) then

			w.CheckMenuItem( window.hmenu, IDM_READONLY, w.MF_BYCOMMAND | w.MF_UNCHECKED );
			mov( false, eax );
			
		else
			
			w.CheckMenuItem(window.hmenu, IDM_READONLY, w.MF_BYCOMMAND | w.MF_CHECKED);
			mov( true, eax );
			
		endif;
		config.writeBool( s_settings, s_readonly, al );
		mov( window.buffer_focus, ebx );
		w.SendMessage( editebx.hred, w.EM_SETREADONLY, eax, 0 );
		updateStatus();
		pop( ecx );
		ret();
	end command_toggle_readonly;


	command_increase_indent :procedure;
	
		// increase indent by adding a tab at bol
		// or strtabs string at bol
		// depending on user settings
		// adjust cursor to maintain relative position.
		
		var
			line		:LineInfo;
			char_index	:dword;
			n_tab		:dword;
			build_str	:string;
	
	begin command_increase_indent;
		mov( str.talloc( 1000 ), build_str );
		mov( window.buffer_focus, esi );
		w.LockWindowUpdate(editesi.hred);
		push( editesi.column_index );
		pop( char_index );
		
		push( editesi.line.number );
		pop( line.number );
		getLineInfo( line );
		
		w.SendMessage( editesi.hred, w.EM_SETSEL, line.index, line.index );
		
		push( esi );
		if( config.readBool( s_settings, s_tabsasspace ) ) then
			str.cpy( strtabs, build_str );
			mov( str.length(strtabs), n_tab );
		else
			str.cpy( "	", build_str );
			mov( 1, n_tab );
		endif;
		pop( esi );

		w.SendMessage( editesi.hred, w.EM_REPLACESEL, true, build_str );
		mov( line.index, eax );
		add( n_tab, eax );
		add( char_index, eax );
		w.SendMessage( editesi.hred, w.EM_SETSEL, eax, eax );
		w.LockWindowUpdate( NULL );
	end command_increase_indent;

	command_reduce_indent :procedure;
	
		// reducs the indent by checking the beginning of the
		// line for tab or space.
		// if tab is found, reduce by 1 char
		// if space is found, reduce by strtabs length of chars
		
		var
			line		:LineInfo;
			cp_min		:dword;
			
			
	begin command_reduce_indent;
		USE( EBX );
		
		mov( window.buffer_focus, ebx );
		w.LockWindowUpdate( editebx.hred );
		push( editebx.line.number );
		pop( line.number );
		getLineInfo( line );
		push( editebx.cursor.start_index );
		pop( cp_min );		
		command_get_line( &buffer );
		if( buffer[0] = $09 ) then
			mov( 1, ecx );
		elseif( buffer[0] = ' ' ) then
			mov( str.length(strtabs), eax );
			for( xor( ecx, ecx ); ecx < eax; inc( ecx ) ) do
				breakif (buffer[ecx] != ' ' );
			endfor;
		else
			xor( ecx, ecx );
		endif;
		
		if( ecx ) then
			push( ecx );
			mov( line.index, eax );
			add( eax, ecx );
			w.SendMessage( editebx.hred, w.EM_SETSEL, eax, ecx );
			w.SendMessage( editebx.hred, w.EM_REPLACESEL, true, s_empty );
			pop( ecx );
		endif;
		
		// adjust the cursor position to maintain it's relative
		// position on the line
		// make sure we don't end up on the previous line

		mov( cp_min, eax );
		if( eax != line.index ) then
			sub( ecx, eax );
			if( eax < line.index ) then
				mov( line.index, eax );
			endif;
		endif;

		w.SendMessage( editebx.hred, w.EM_SETSEL, eax, eax);
		w.LockWindowUpdate(NULL);
		
		ENDUSE;
	end command_reduce_indent;

	
	Msg_Command :procedure( hwin:dword; wparam:dword; lparam:dword );
	
		// handle menu commands
		readonly
			s_set_date_format :string := "Set Date Format";
			s_set_time_format :string := "Set Time Format";
			s_set_default_extension :string := "Set Default Extension";
			
	
	begin Msg_Command;
		mov	(wparam,eax);
		and	($0ffff,eax);
		
		mov( window.buffer_focus, ebx );
		switch( eax );
		case( IDM_NEW )
			
			getConfirm();
			if (!eax) then	
				
				w.SetWindowText( editebx.hred, 0 );		// clear edit window
				str.cpy( s_untitled, editebx.filepath );
				mov( MODE_INSERT, editebx.mode );
				mov( false, editebx.mark );
				updateStatus();
				
			endif;
			w.SetFocus( editebx.hred );
		
		case( IDM_OPEN )
		
			getConfirm();
			if (!eax) then
			
				fileOpen(); 
	
			endif;	
			w.SetFocus( editebx.hred );
			
		case( IDM_INST )
			
			command_new_instance( NULL );
			
		case( IDM_SAVE )
		
			checkSave();
			w.SetFocus( editebx.hred );
			
		case( IDM_SAVEAS )
		
			SaveAs();
			w.SetFocus( editebx.hred );
			
		case( IDM_SAVE_SELECTION_AS )
		
			SaveSelectionAs();
			w.SetFocus( editebx.hred );
			
	   	case( IDM_CUT )
		
			w.SendMessage( editebx.hred, w.WM_CUT, 0, 0 );
			
		case( IDM_COPY )
		
			w.SendMessage( editebx.hred, w.WM_COPY, 0, 0 );
			
		case( IDM_PASTE )
		
			w.SendMessage( editebx.hred, w.WM_PASTE, 0, 0 );
			w.SendMessage( editebx.hred, w.EM_SETMODIFY, true, 0 ); 	
			
		case( IDM_SELECTALL )	
			command_select_all();
			
		case( IDM_COPY_WORD )
			command_copy_word();
			
		case( IDM_DELETE_WORD )
			command_delete_word();
			
		case( IDM_KILL_LINE )
			command_cut_line();
			
		case( IDM_UNDO )
		
			w.SendMessage( editebx.hred, w.EM_UNDO, 0, 0 );
			
		case( IDM_REDO )
		
			w.SendMessage( editebx.hred, w.EM_REDO, 0, 0 );
						
		case( IDM_FIND, IDM_REPLACE )
			if (!window.hfind) then
				GetSelText (&findbuf);
				w.CreateDialogParam(window.hinst,val ID_FINDDLG,window.hwnd, &Proc_FindDlg,false);
			else
				w.SetFocus(window.hfind);
			endif;
		
		case( IDM_FINDNEXT )
			
			mov( true, window.find_mode.down );
			
			if (! window.hfind) then
				GetSelText(&findbuf);
			endif;
			mov( findbuf[0], al );
			test(al,al);
			if (@nz) then
				Find( MINUS_ONE );
			endif;
			
		case(IDM_FINDPREV )
			
			mov( false, window.find_mode.down );
			
			if (! window.hfind) then
				GetSelText(&findbuf);
			endif;
			mov (findbuf[0], al);
			test(al,al);
			if (@nz) then
				Find( MINUS_ONE );
			endif;
			
		case( IDM_EDIT_GOTO )
			
			str.cpy( s_empty, input.initial );
			w.DialogBoxParam( window.hinst, val ID_INPUT, hwin, &Proc_Input, s_inputlinen );
			if( return > 0 ) then
				
				dbg.put("query :", input.return );
				
				try
					//conv.strTou32( return, 0 );
					conv.strTou32( input.return, 0 );
					dec(eax);
					w.SendMessage( editebx.hred, w.EM_LINEINDEX, eax, 0 );
					w.SendMessage( editebx.hred, w.EM_SETSEL, eax, eax );
					//w.SendMessage( editebx.hred, w.EM_SCROLLCARET, 0, 0 );
					
				anyexception
					
					str.init( &buffer, 100 );
					mov( eax, edi );
					str.put( (type string edi), "Can't go to line ", input.return );
					Error( edi, true );
					
				endtry;
				
			endif;
			
		case( IDM_DATE_TIME )
			command_insert_date_time();
			
		case( IDM_DATE )
			command_insert_date();
		
		case( IDM_TIME )
			command_insert_time();
			
		case( IDM_FONT )
		
			selectFont();
			w.SetFocus( editebx.hred );
			
		case( IDM_FOREGROUND )
			
			if( selectColor() )  then
				move( return, window.textColor );
				config.writeHex( s_text, s_text_color, window.textColor);
				setFont();
			endif; 
			w.SetFocus( editebx.hred );
			
		case( IDM_BACKGROUND )
	
			if( selectColor() ) then
				move( return, window.backColor );
				config.writeHex( s_text, s_background_color, window.backColor);
				w.SendMessage( editebx.hred, w.EM_SETBKGNDCOLOR, false, window.backColor);
			endif;
			w.SetFocus( editebx.hred );
			
		case(IDM_AUTO ) 
			
			if( config.readBool( s_settings, s_autosave ) ) then
			
				w.CheckMenuItem( window.hmenu, IDM_AUTO, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
				
			else
				
				w.CheckMenuItem( window.hmenu, IDM_AUTO, w.MF_BYCOMMAND | w.MF_CHECKED );
				mov( true, eax );
				
			endif;
			
			config.writeBool( s_settings, s_autosave, al );
			
		case(  IDM_AUTOINDENT ) 
			
			if( config.readBool( s_settings, s_autoindent ) ) then
			
				w.CheckMenuItem( window.hmenu, IDM_AUTOINDENT, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
				
			else
				
				w.CheckMenuItem( window.hmenu, IDM_AUTOINDENT, w.MF_BYCOMMAND | w.MF_CHECKED );
				mov( true, eax );
				
			endif;
			
			config.writeBool( s_settings, s_autoindent, al );
		
		case( IDM_CRLF )
			config.writeString( s_settings, "Line Break", "CRLF" );
			w.CheckMenuItem( window.hmenu, IDM_CRLF, w.MF_BYCOMMAND | w.MF_CHECKED );
			w.CheckMenuItem( window.hmenu, IDM_LF, w.MF_BYCOMMAND | w.MF_UNCHECKED );
			
		case( IDM_LF )
			config.writeString( s_settings, "Line Break", "LF" );
			w.CheckMenuItem( window.hmenu, IDM_CRLF, w.MF_BYCOMMAND | w.MF_UNCHECKED );
			w.CheckMenuItem( window.hmenu, IDM_LF, w.MF_BYCOMMAND | w.MF_CHECKED );
			
		case( IDM_ACTIVE_URL ) 
			
			if( config.readBool( s_settings, "Active URL" )) then
				w.CheckMenuItem( window.hmenu, IDM_ACTIVE_URL, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				config.writeBool( s_settings, "Active URL", false );
				updateActiveURL();
			else
				getConfirm();
				if( ! eax ) then
					w.CheckMenuItem( window.hmenu, IDM_ACTIVE_URL, w.MF_BYCOMMAND | w.MF_CHECKED );
					config.writeBool( s_settings, "Active URL", true );
					saveFile( editebx.filepath, false );
					updateActiveURL();
					loadFile( editebx.filepath );
				endif;
			endif;
			
		case( IDM_DATE_FORMAT )
			config.readString( s_settings, "Date Format", input.initial );
			w.DialogBoxParam( window.hinst, val ID_INPUT, hwin, &Proc_Input, s_set_date_format );
			if( return > 0 ) then
				dbg.put("query :", input.return );
				config.writeString( s_settings, "Date Format", input.return );
			endif;

		case( IDM_TIME_FORMAT )
			config.readString( s_settings, "Time Format", input.initial );
			w.DialogBoxParam( window.hinst, val ID_INPUT, hwin, &Proc_Input, s_set_time_format );
			if( return > 0 ) then
				dbg.put("query :", input.return );
				config.writeString( s_settings, "Time Format", return );
			endif;
		
		case( IDM_INCREASE_INDENT )
			command_increase_indent();
		
		case( IDM_DECREASE_INDENT )
			command_reduce_indent();
		
		case( IDM_DEFAULT_EXT )
			config.readString( s_settings, "Default Extension", input.initial );
			w.DialogBoxParam( window.hinst, val ID_INPUT, hwin, &Proc_Input, s_set_default_extension );
			if( return > 0 ) then
				dbg.put("query :", input.return );
				str.cpy( input.return, default_extension ); 
			else
				str.cpy( s_empty, default_extension );
			endif;
			
			config.writeString( s_settings, "Default Extension", default_extension );

		case( IDM_TO_UPPER )
			command_uppercase_selection();
					
		case( IDM_TO_LOWER )
			command_lowercase_selection();

		case( IDM_EDITINI )
			
			dbg.put("edit the ini file");
			getConfirm();
			if (!eax) then
			
				command_edit_ini(); 
	
			endif;	

		case ( IDM_WRAP) 

			if( config.readBool( s_settings, s_wrap ) ) then

				w.CheckMenuItem( window.hmenu, IDM_WRAP, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, editebx.word_wrap );
				
			else
				
				w.CheckMenuItem( window.hmenu, IDM_WRAP, w.MF_BYCOMMAND | w.MF_CHECKED );
				mov( true, editebx.word_wrap );
				
			endif;
			
			config.writeBool( s_settings, s_wrap, editebx.word_wrap );
			if( editebx.word_wrap ) then
				w.SendMessage( editebx.hred, w.EM_SETTARGETDEVICE, NULL, 0 );
			else
				w.SendMessage( editebx.hred, w.EM_SETTARGETDEVICE, NULL, 1 );
			endif;
			
		case ( IDM_READONLY) 
			
			command_toggle_readonly();
			
		case ( IDM_CLEAREXIT) 

			if( config.readBool( s_settings, s_clearexit ) ) then

				w.CheckMenuItem( window.hmenu, IDM_CLEAREXIT, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
			else
				
				w.CheckMenuItem(window.hmenu, IDM_CLEAREXIT, w.MF_BYCOMMAND | w.MF_CHECKED);
				mov( true, eax );
			endif;
			config.writeBool( s_settings, s_clearexit, al );
			
		case ( IDM_RECENTNEW) 
			
			if( config.readBool( s_settings, s_recentnew ) ) then

				w.CheckMenuItem( window.hmenu, IDM_RECENTNEW, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
				
			else
				
				w.CheckMenuItem(window.hmenu, IDM_RECENTNEW, w.MF_BYCOMMAND | w.MF_CHECKED);
				mov( true, eax );
				
			endif;
			config.writeBool( s_settings, s_recentnew, al );
			
		case ( IDM_OPENRECENT) 

			if( config.readBool( s_settings, s_openrecent ) ) then

				w.CheckMenuItem( window.hmenu, IDM_OPENRECENT, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
				
			else
				
				w.CheckMenuItem(window.hmenu, IDM_OPENRECENT, w.MF_BYCOMMAND | w.MF_CHECKED);
				mov( true, eax );
				
			endif;
			config.writeBool( s_settings, s_openrecent, al );
			
		case(  IDM_REMEMBERPOS ) 
		
			if( config.readBool( s_settings, s_rememberpos ) ) then

				w.CheckMenuItem( window.hmenu, IDM_REMEMBERPOS, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
				
			else
				
				w.CheckMenuItem(window.hmenu, IDM_REMEMBERPOS, w.MF_BYCOMMAND | w.MF_CHECKED);
				mov( true, eax );
				
			endif;
			config.writeBool( s_settings, s_rememberpos, al );
			
		case ( IDM_PEG) 

			if( config.readBool( s_settings, s_topwindow ) ) then

				w.CheckMenuItem( window.hmenu, IDM_PEG, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				w.SetWindowPos(hwin,w.HWND_NOTOPMOST,0,0,0,0,3);
				mov( false, eax );
				
			else
				
				w.CheckMenuItem(window.hmenu, IDM_PEG, w.MF_BYCOMMAND | w.MF_CHECKED);
				w.SetWindowPos(hwin,w.HWND_TOPMOST,0,0,0,0,3);
				mov( true, eax );
				
			endif;
			config.writeBool( s_settings, s_topwindow, al );
		
		case(  IDM_SETTAB ) 
			
			if( setTabWidth() ) then
				config.writeUns( s_settings, s_tabs, eax );
				setTabs();
			endif;
			
		case( IDM_TAB_AS_SPACE )
		
			if( config.readBool( s_settings, s_tabsasspace ) ) then

				w.CheckMenuItem( window.hmenu, IDM_TAB_AS_SPACE, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				mov( false, eax );
					
			else
				
				w.CheckMenuItem(window.hmenu, IDM_TAB_AS_SPACE, w.MF_BYCOMMAND | w.MF_CHECKED);
				mov( true, eax );
				
			endif;
			config.writeBool( s_settings, s_tabsasspace, al );			
			
		case(  IDM_VIEW_STATUS ) 
			
			if( config.readBool( s_window, s_status ) ) then
				
				config.writeBool( s_window, s_status, false );
				w.CheckMenuItem( window.hmenu, IDM_VIEW_STATUS, w.MF_BYCOMMAND | w.MF_UNCHECKED );
				w.ShowWindow( window.hstatus, false );
				
			else
				
				config.writeBool( s_window, s_status, true );
				w.CheckMenuItem( window.hmenu, IDM_VIEW_STATUS, w.MF_BYCOMMAND | w.MF_CHECKED );
				w.ShowWindow( window.hstatus, true );
				
			endif;
			w.SendMessage( hwin, w.WM_SIZE, 0, 0 );
			
		case ( IDM_ABOUT) 
		
			w.CreateDialogParam(window.hinst,val ID_ABOUT,hwin,&AboutDlgProc,0);
	
		case ( IDM_DOCUMENTS) 
			
			//getConfirm();
			//if (!eax) then
				
				command_new_instance( "-h" );
	
			//endif;	
	
		case( IDM_QUIT ) 
		
			 w.SendMessage(hwin,w.WM_CLOSE,0,0);
		
		default;
			if( eax >= RECENT_MENU_START && eax <= RECENT_MENU_END ) then
				openRecent( eax );
			endif;
		endswitch;
		
		updateStatus();
		xor( eax, eax );

	end Msg_Command;

	pipe_input	:procedure;
	begin pipe_input;
		dbg.put("piping");
		if( stdin.handle() ) then
			setText( eax );
		endif;
	end pipe_input;


	// check for a filename passed as an argument and try to open that file.
	// if file doesn't exist, start new document with that filename.
	processCommandLine	:procedure;
	
		var
			build_str		:string;
			openfilename	:string;
			argc			:uns8;
				
	begin processCommandLine;
		
		mov( str.talloc(1000), build_str );
		mov( str.talloc(1000), openfilename );
		arg.c();
		mov( al, argc );
		xor( ecx, ecx );
		
		while( argc > 1 ) do

			inc( ecx );
			arg.v( ecx );
			dbg.put("v eax = ", (type string eax ));
			mov( (type byte[eax]), dl );
			if( dl = '-' || dl = '/' ) then
				movzx( (type byte[eax+1]), edx );
				chars.toLower( dl );
				switch( edx );
				case( 'r' )
					config.writeBool( s_settings, s_readonly, true );

				case( 'h' )
					push( ecx );
					command_display_manual();
					pop( ecx );
					jmp done;
				case( 'e' )
					command_edit_ini();
					// if we open manual, nothing else needs to be done
					jmp done;
					
				case( 's' )
					pipe_input();
					jmp done;
				endswitch;
	
			else

				// we may support opening multiple file names
				// once multi-buffers are addeed.
				push( ecx );
				str.cpy( (type string eax), openfilename );
				w.GetLongPathName( eax, &buffer, @size(buffer) -1 );
				if( eax ) then
					str.cpyz( &buffer, openfilename );
				endif;
				pop( ecx );
			endif;
			dec( argc );
		
		endwhile;
		
		dbg.put("openfilename :", openfilename );
		
		// if openfilename has any content, open it or create new
		// otherwise see if we need to open recent
		if( str.length( openfilename ) > 0 ) then
			
			if( filesys.exists( openfilename )) then
				loadFile( openfilename );
				if (eax) then
					if( config.readBool( s_settings, s_rememberpos )) then
						config.readUns( s_settings, "Start Position");
						mov( window.buffer_focus, esi );
						mov( eax, editesi.cursor.start_index );
						mov( eax, editesi.cursor.end_index );
						lea( edi, editesi.cursor );
						w.SendMessage( editesi.hred, w.EM_EXSETSEL, 0, edi );
					endif;
					//exit processCommandLine;
				endif;
			else
				
				// there is no file, create a new document with name passed on command line
				mov( window.buffer_focus, esi );
				str.cpy( openfilename, editesi.filepath );
			endif;		
		else
		
			// no file requested as an argument,
			// check config to see if we want to open the most recent document
	
			if( config.readBool( s_settings, s_openrecent ) ) then
				
				// we want to open the most recent file. do we have a recent file to open?
				
				if( config.isSectionDefined( s_recent )) then
					
					config.readItem( s_recent, 0, build_str );
					loadFile( build_str );
					if( ! eax ) then
						
						// the file we want to open doesn't exit anymore. remove it from our list.
						config.deleteItem( s_recent, 0 );
	
					endif;
					
					// do we want to move the cursor to the position it was when the file was closed?
					
					if( config.readBool( s_settings, s_rememberpos )) then
						config.readUns( s_settings, "Start Position");
						mov( window.buffer_focus, esi );
						mov( eax, editesi.cursor.start_index );
						mov( eax, editesi.cursor.end_index );
						lea( edi, editesi.cursor );
						w.SendMessage( editesi.hred, w.EM_EXSETSEL, 0, edi );
					endif;
					
				endif;
				
			endif;
		endif;
		
		
		done:
			getInfo();
			updateMenu();
			updateStatus();
	end processCommandLine;


begin SavageEd;

	dbg.cls;
	mov( false, proc_return );
	mem2.fillMem( &keystate, @elements( keystate ), 0 );
	
	// NOTE: This is the initial implementation of the buffer list. currently it holds
	//	  only one buffer, which is identified as 'info'
		
	BufferList.create();
	mem.alloc( @size( Edit_Node ));
	mov( eax, window.buffer_focus );
	BufferList.append( window.buffer_focus );

	initConfig();
	initWindow();
	processCommandLine();
	
	mov( window.buffer_focus, ebx );
	mov( MODE_INSERT, editebx.mode );

	
	FOREVER
		w.GetMessage(window.msg,NULL,0,0);
		breakif( ! eax );
		w.IsDialogMessage( window.hfind, window.msg );
		continueif( eax );
		w.IsDialogMessage( window.habout, window.msg );
		continueif( eax );
		w.TranslateMessage( window.msg );
		w.DispatchMessage( window.msg );		
	ENDFOR;
	
	// tail free some resources
	// unnecessary, but helpful to know what needs to be freed in case
	// we decide to move things around later
	
	TODO( "not that it's important since we are exiting anyway, here is where we would clear all the list buffers" )
	mov( window.buffer_focus, ebx );
	w.DestroyWindow( editebx.hred );
	w.DeleteObject( window.hfont );
	w.FreeLibrary(window.hredDLL);
	
	mov( window.buffer_focus, esi );
	str.free( editesi.filepath );
	
	BufferList.destroy();

	mov( window.msg.wParam, eax );

	_exit:

end SavageEd;
