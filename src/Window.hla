unit Window_unit;
	
	#include("SavageEd.hhf")

// for now, this is just a place to leave procedures that are fairly complete
// and don't need to be updated or worried about for new functions.
// mostly to declutter SavageEd.hla 

readonly

	

// main window message table
//bm=window_commands	
	message_table	:MsgProcPtr_t; @nostorage;
		MsgProcPtr_t	
			MsgProcPtr_t:[ w.WM_COMMAND,	&Msg_Command			],
			MsgProcPtr_t:[ w.WM_DESTROY,	&Msg_Destroy			],
			MsgProcPtr_t:[ w.WM_CLOSE,		&Msg_Close				],
			MsgProcPtr_t:[ w.WM_CREATE,		&Msg_Create				],
			MsgProcPtr_t:[ w.WM_SIZE,		&Msg_Size				],
			MsgProcPtr_t:[ w.WM_CONTEXTMENU,&Msg_Context			],
			MsgProcPtr_t:[ w.WM_SETFOCUS,	&Msg_SetFocus			],
			MsgProcPtr_t:[ w.WM_DROPFILES,  &Msg_OpenDroppedFile	],
			MsgProcPtr_t:[ w.WM_NOTIFY,		&Msg_Notify],

			// add more messages here
			MsgProcPtr_t:[ 0, NULL ];	// This marks the end of the list.

readonly
// this is the main configuration file name
	config_file		:string := "SavageEd.ini";
	
	s_window 	:string := "Window";
	ClassName	:string:= "SavageEDClass";
	AppName		:string:= "SavageEd";
	
	RichEditDLL		:string := "riched32.dll";
	//RichEditDLL		:string := "riched20.dll";
	
	// strings and error messages
	s_recent	:string := "Recent Files";
	s_settings	:string := "Settings";
	s_tabs		:string := "Tabs";
	s_tabsasspace:string	:= "Tabs as Spaces";
	s_font		:string := "Font";
	s_find		:string := "Find";
	s_text		:string := "Text";
	s_background_color	:string := "Background Color";
	s_text_color		:string := "Text Color";
	s_custcolors:string := "Custom Colors";
	s_openrecent:string := "Open Recent";
	s_rememberpos :string := "Remember Position";
	s_wrap		:string := "Word Wrap";
	s_autosave	:string := "Auto Save";
	s_autoindent:string := "Auto Indent";
	s_topwindow	:string := "Top Window";
	s_status	:string := "show status";
	s_clearexit	:string := "Clear On Exit";
	s_recentnew	:string := "New Recent Window";
	s_readonly	:string := "Read Only";
	s_resedClass:string := "RichEdit20A";
	s_untitled	:string := "Untitled";
	s_txtext	:string := ".txt";
	s_fontname	:string := "Courier New";
	s_nl		:string := nl;
	s_r			:string := "R";
	s_b			:string := " ";
	s_mark		:string := "M";
	s_empty		:string := "";
	s_lf		:string := "LF";
	s_crlf		:string := "CRLF";
	s_inputlinen:string := "Enter Line Number";
	s_inputtab	:string := "Enter tab spacing in number of characters";
	
	s_document		:string := "SavageEd.md";	
	s_missingDLL	:string := "Could not open Riched32.dll";
	s_missingDocs	:string := "Missing Documents: SavageEd.md";
	s_nosave		:string := "Could Not Save File";
	s_noopen		:string := "Unable to open file";
	s_notemp		:string := "Unable to create temporary file";
	s_savechanges	:string := "Save changes to ";
	//s_savetitle		:string := "Save As: Extension Is Not Assumed";
	s_savetitle		:string := "Save As:";
	
	curdir			:byte := '.';	// '.' = curdir

storage
	editstream	:w.EDITSTREAM;

static
	default_date_format :string := "MM-dd-yyyy";
	default_time_format :string := " hh:mm:tt";
	default_extension	:str.strvar(w.MAX_PATH);	//.string := "";
	input	:InputInfo;
	
proc

	initWindow	:procedure {@noframe};
	
	//	window creation initialization goes here
	//	register and create window.
		
	//	returns:
	//		success = true in eax
	//		failure = false in eax
		static 	wc:w.WNDCLASSEX;

	begin initWindow;
		
		w.GetModuleHandle( NULL );
		mov( eax, window.hinst );
		mov( window.buffer_focus, esi );
		mov( str.alloc( 1000 ), editesi.filepath );
		
		w.LoadLibrary( RichEditDLL );
		if (eax = NULL ) then
			Error( s_missingDLL, false );
			xor(eax,eax);
			ret();
	    endif;
	    
		mov	(eax,window.hredDLL);
		
		w.InitCommonControls();
		str.cpy( s_untitled, editesi.filepath );

		mov( 0, findbuf[0] );
		mov( 0, replacebuf[0] );
		
		// main window created here
		// describe and register the window class
		mov( @size(w.WNDCLASSEX), wc.cbSize );
		mov( w.CS_HREDRAW | w.CS_VREDRAW, wc.style );
		mov( &WndProc, wc.lpfnWndProc );
		mov( NULL, wc.cbClsExtra );
		mov( NULL, wc.cbWndExtra );
		mov( window.hinst, wc.hInstance );
		mov( w.COLOR_BTNFACE+1, wc.hbrBackground );
		mov( ClassName, wc.lpszClassName );
		
		w.LoadIcon(window.hinst, val ID_JAKAL);
		mov( eax, wc.hIcon );
		mov( eax, wc.hIconSm );
		w.LoadCursor( NULL, val w.IDC_ARROW );
		mov( eax,wc.hCursor );
		
		// register the window class
		if ( ! w.RegisterClassEx( wc )) then
			Error( "Unable to register Window Class", false);
			ret();
		endif;
			
		// create the window
		w.CreateWindowEx(
				NULL,					// dwExStyle
				ClassName,
				AppName,
				w.WS_OVERLAPPEDWINDOW,
				window.xPos,
				window.yPos,
				window.width,
				window.height,
				NULL,					// hWndParent
				NULL,					// hMenu
				window.hinst,
				NULL );					// lpParam
				
		if( ! eax ) then
			Error( "Unable to create window", false);
			ret();
		endif;
		
		w.ShowWindow( window.hwnd, w.SW_SHOWNORMAL );
		w.UpdateWindow( window.hwnd );
		ret();
	end initWindow;

	WndProc :procedure( lparam:dword; wparam:dword; umsg:uns32; hwin:dword );
	
		// main window message handler
	
	begin WndProc;
		pushabi;
		mov(umsg,eax);
		mov(&message_table,edx);
		
		FOREVER
			mov( (type MsgProcPtr_t [edx]).MessageHndlr, ecx );
			IF( ecx = 0 ) THEN
				w.DefWindowProc( hwin, umsg, wparam, lparam );
				EXIT WndProc;
			ELSEIF( eax = (type MsgProcPtr_t [edx]).MessageValue ) THEN
	
				push( hwin );
				push( wparam );
				push( lparam );
				call( ecx );
				BREAK;
			ENDIF;
			add( @size( MsgProcPtr_t ), edx );
		ENDFOR;
	
		popabi;
	end WndProc;

	Error :procedure( error_msg:string; warning:boolean );

		// quick message box for critical errors and warnings reporting

	begin Error;
	
		if( warning ) then
			
			w.MessageBox( NULL, error_msg, "Warning", w.MB_OK );
		
		else
			
			w.MessageBox(NULL,error_msg,"ERROR",w.MB_OK | w.MB_ICONERROR );
			
			cmp(window.hwnd,0);
			je _nowindow;
			w.PostQuitMessage(0);
			exit Error;
			
		_nowindow:
			xor(eax,eax);
			
		endif;
	
	end Error;

	Msg_Size :procedure( hwin:dword; wparam:dword; lparam:dword );
		
		// size the main window
		
		var
			rect	:w.RECT;
			height	:dword;

	begin Msg_Size;
		
		w.GetClientRect( window.hwnd, rect );
		mov( rect.bottom, eax );
		sub( rect.top, eax );
		mov( eax, height );
		
		if( config.readBool( s_window, s_status ) ) then
		
			sub( STATUS_BAR_HEIGHT, height );
			w.SendMessage( window.hstatus, w.WM_SIZE, 0, 0 );

		endif;
		mov( window.buffer_focus, eax );
		w.MoveWindow( editeax.hred, 0, rect.top, rect.right, height, true );
		xor( eax, eax );
	end Msg_Size;
		
	Msg_SetFocus :procedure( hwin:dword; wparam:dword; lparam:dword );
	
		// set window focus to active editor control
	
	begin Msg_SetFocus;
		mov( window.buffer_focus, eax );
		w.SetFocus( editeax.hred );
		xor( eax, eax );
	end Msg_SetFocus;


	Msg_Destroy :procedure( hwin:dword; wparam:dword; lparam:dword );
		
		// exit protocls
		// save settings and post-close cleanups
		
		var
			wndpos	:w.WINDOWPLACEMENT;
			rect		:rect_t;
			config_path	:string;
			
	begin Msg_Destroy;
	
		dbg.put("destroy");
		mov( str.talloc(400), config_path );
		w.GetWindowPlacement( hwin, wndpos );
		w.GetWindowRect( hwin, rect );
		mov( rect.left,window.xPos );
		mov( rect.top,window.yPos );
		mov( rect.right, eax );
		sub( rect.left, eax );
		mov( eax,window.width );
		mov( rect.bottom, eax );
		sub( rect.top, eax );
		mov( eax,window.height );
		
		config.writeUns( s_window, "xPos", window.xPos );
		config.writeUns( s_window, "yPos", window.yPos );
		config.writeUns( s_window, "width", window.width );
		config.writeUns( s_window, "height", window.height );
		config.writeBin( s_text, s_find, &window.find_mode, @size( window.find_mode ) );
		
		mov( window.buffer_focus, eax );
		config.writeUns( s_settings, "Start Position", editeax.cursor.start_index );
		
		if( config.readBool( s_settings, s_clearexit ) ) then
			
			dbg.put("deleting recent");
			config.deleteSection( s_recent );

		endif;

		getConfigPath( config_path );
		config.writeFileName( config_path );
		
	 	w.PostQuitMessage( NULL );
	 	xor( eax, eax );
			
	end Msg_Destroy;


	Msg_Close :procedure( hwin:dword; wparam:dword; lparam:dword );
	
		// close app. warn about unsaved changes
	
	begin Msg_Close;
	
	 	getConfirm();
		if (!eax) then
		 	w.SendMessage(hwin, w.WM_DESTROY, 0, 0 );
		 	
		endif;
		
		xor( eax, eax );
		
	end Msg_Close;

	
	StreamInProc :procedure( var pBytesRead:dword ; NumBytes:dword ; var pbuffer:dword ; _hFile:dword );	

		// read file into edit buffer

	begin StreamInProc;
		
		w.ReadFile( _hFile, pbuffer, NumBytes, pBytesRead, NULL );
		xor	(1, eax);
	
	end StreamInProc;

	StreamOutProc :procedure( var pBytesWritten:dword ; NumBytes:dword ; var pbuffer:dword ; _hFile:dword );
	
		// stream the contents of the richedit to file
		// richedit doesn't have a flag to return LF line ending even though
		// this is it's default internal representation.\
		// what can i say, windows api sucks.
		// in order to strip CR from line endings, we have to go through
		// a hackey process.
		
		
		var
			buf	:tBuffer;
			returnval	:dword;
		
		static
			cr_linebreak : cset := { #$0D };
			
	
	begin StreamOutProc;
		
		if( window.line_break = LF ) then
			
			// user request LF linebreaks, begin hacky stuff
			// i'll note all the hacky stuff i do. 
			
			pushad();
			
			// first, we'll copy the buffer to our custom buffer/scanner
			// to make life a little easier
			
			buf.create( NumBytes );
			mov( pbuffer, ecx );
			buf.putBytes( ecx, NumBytes );
			buf.bof();
			
			// now scan through our buffer, breaking everytime we find a CR
			// and delete that pesky dingy. 
			forever
				breakif( buf.isEof() );
				if( buf.brk( cr_linebreak ) ) then
					buf.delete(1);
				endif;
			endfor;

			w.WriteFile( _hFile, val buf.data, buf.length, pBytesWritten, NULL );
			mov( eax, returnval );
			
			// now since we removed some bytes from the buffer,
			// the length will be less than what richedit is expecting
			// and it will stop. so we have to trick it into thinking
			// we wrote everything it wanted us to write.

			mov( pBytesWritten, eax );
			mov( NumBytes, [eax] );
			buf.destroy();
			popad();
			
		else

			w.WriteFile( _hFile, pbuffer, NumBytes, pBytesWritten, NULL );
			mov( eax, returnval );			
			// use normal write routine.

		endif;
		
		// we have to toggle the return bit to make everything work smoothly.
		mov( returnval, eax );
		xor	(1, eax);
		
	end StreamOutProc;

	setWindowTitle :procedure;
	
		// set the window title
		// called anytime the title needs to be changed or updated
		var
			title	:string;
			
	
	begin setWindowTitle;
		
		mov( str.talloc(1000), title );
		mov( window.buffer_focus, esi );
		filesys.extractFilename( editesi.filepath, title );
		str.insert3( "SavageEd.exe - ", 0, title );
		if( editesi.hred ) then
			if (w.SendMessage( editesi.hred, w.EM_GETMODIFY,0,0 )) then
				str.insert( "*", 0, title );
			endif;
		endif;
		w.SetWindowText( window.hwnd, title );

	end setWindowTitle;

	getTempName :procedure( prefix:string; ext:string; dest:string );
	
		// gets a temp name based on current directory
		// format:
		// curdir\prefixxxxxxxxxext
		var
			s	:string;
			
	begin getTempName;
		
		mov( str.talloc(400), s );
		// doubt there will ever be a similar result, but just in case...
		forever
			w.GetTickCount();
			conv.u32ToStr( eax, 20, ' ', s );
			str.trim( s );
			filesys.gwd( dest );
			str.put2( dest, chars.dir_sep, prefix, s, ext );
			
			breakif( ! filesys.exists( dest ) );
		endfor;
		
	end getTempName;

	getConfirm :procedure { @noframe};

		// checks for modified file, gets confirmation from user

	begin getConfirm;
		USE( ESI );
		mov( window.buffer_focus, ebx );
		w.SendMessage( editebx.hred, w.EM_GETMODIFY, 0, 0 );
		if( eax ) then
			if( config.readBool( s_settings, s_autosave ) ) then

				checkSave();
				mov( false, eax );
			
			else
				
				w.MessageBox( window.hwnd, editebx.filepath, s_savechanges, w.MB_YESNOCANCEL | w.MB_ICONQUESTION);
				if( eax=w.IDYES ) then
						
					checkSave();
					xor( eax, eax );
					
				elseif (eax=w.IDNO) then
			
					xor( eax, eax );
			
				else
			 
					mov( true, eax );
					
				endif;
				
			endif;
		else
			
			xor( eax, eax );
			
		endif;
		ENDUSE;
		ret();
	end getConfirm;

	checkSave :procedure { @noframe };
	
		// checks to see if the current document has a title
		// if not, it will generate a random name if that
		// option is on.
	
	begin checkSave;
		USE( EBX );
		mov( window.buffer_focus, ebx );
		if( str.ieq( editebx.filepath, s_untitled ) ) then
			
			if( config.readBool( s_settings, s_autosave ) ) then
				
				getTempName( s_untitled, s_txtext, editebx.filepath );
				mov( 0, eax );
			else
				
				SaveAs();
				
			endif;
		else
			
			mov( 0, eax );
			
		endif;
		
		if( ! eax  ) then
			saveFile( editebx.filepath, false );
		endif;
		updateStatus();
		ENDUSE;
		ret();
	end checkSave;

	SaveAs :procedure {@noframe};
	
		// save the current file under a new name
		// new name becomes default
	
	begin SaveAs;
		USE( ESI );
		
		getFileName();
		if( eax ) then
			mov( window.buffer_focus, esi );
			str.cpyz( &buffer, editesi.filepath );
			if( ! filesys.hasExtension( editesi.filepath )) then
				str.cat( default_extension, editesi.filepath );
			endif;
			
			saveFile( editesi.filepath, false );
			if(eax) then
			 	// reset FileName to untitled
			 	str.cpy( s_untitled, editesi.filepath );

			endif; 
			
			mov( MODE_INSERT, editesi.mode );
			dbg.put("mode to :", editesi.mode );
			xor( eax, eax );
			
		else
			
			mov(-1,eax);
			
		endif;
		
		ENDUSE;
		ret();
	end SaveAs;

	SaveSelectionAs :procedure;
	
		// save selected text with new name
		// does not change current document.
		var
			fname	:string;
			
	begin SaveSelectionAs;
		
		mov( str.talloc(1000), fname );
		getFileName();	
		if(eax) then
			
			str.cpyz( &buffer, fname );
			saveFile( fname, true );
		endif;

	end SaveSelectionAs;


	saveFile :procedure( filename:string; save_selection:boolean );

		// saves contents of edit buffer or selection to file
		var
			hfile	:dword;
			
	begin saveFile;
		USE( ESI );
		dbg.put("saving filename:", filename );
		try
			fileio.openNew( filename );
			mov( eax,hfile );
			mov( eax, editstream.dwCookie );
			mov( &StreamOutProc, editstream.pfnCallback );
			mov( w.SF_TEXT, eax );
			if( save_selection ) then
				or( w.SFF_SELECTION, eax );
			endif;
			mov( window.buffer_focus, esi );
			w.SendMessage( editesi.hred, w.EM_STREAMOUT, eax, &editstream );
			fileio.close( hfile );
			w.SendMessage( editesi.hred, w.EM_SETMODIFY, false, 0 );
			mov( false,eax );

			if( editesi.mode = MODE_EDITINI ) then
				initConfig();
			endif;
			
		anyexception
			
			Error( s_nosave, true );
			mov( true, eax );
			
		endtry;
		push( eax );
		updateRecentLog();
		updateStatus();
		pop( eax );
		done:
		ENDUSE;
	end saveFile;

	getFileName	:procedure;
	
		// copies the current filename into buffer
		var
			ofn	:w.OPENFILENAME;
			build_str	:string;
			
	
	begin getFileName;
		USE( ESI );
		
		mov( str.talloc(1000), build_str );
		lea( ofn, eax );
		mem2.fillMem( [eax], @size( ofn ), 0 );
		mov( @size( ofn ), ofn.lStructSize );
		mov( window.hwnd, ofn.hWndOwner );
		mov( window.hinst, ofn.hInstance );
		mov( &curdir, eax );
		mov( eax, ofn.lpstrInitialDir );
		
		mov( window.buffer_focus, esi );
		if( str.eq( editesi.filepath, s_untitled ) ) then
			str.put( build_str, '*', default_extension );
			zstr.cpy( (type zstring build_str ), &buffer );
		else
			zstr.cpy( (type zstring editesi.filepath ), &buffer );
		endif;
		mov( &buffer, eax );
		mov( eax, ofn.lpstrFile );
		mov( s_savetitle, eax );
		mov( eax, ofn.lpstrTitle );
		mov( @elements(buffer)-1, ofn.nMaxFile );
		mov( w.OFN_EXPLORER | w.OFN_LONGNAMES | w.OFN_OVERWRITEPROMPT, ofn.Flags );
		
		dbg.put("ofn");
		w.GetSaveFileName( ofn );
		
		ENDUSE;
	end getFileName;


	setText :procedure( hfile:dword );
	
		// load a file into the buffer
	
	begin setText;
		USE( ESI );
		
		mov( window.buffer_focus, esi );
		w.SetWindowText( editesi.hred, 0 );
		w.GetFileSize( hfile, NULL );
		if( eax > 0 ) then
			mov( hfile, editstream.dwCookie );
			mov( &StreamInProc, editstream.pfnCallback );
			w.SendMessage( editesi.hred, w.EM_STREAMIN, w.SF_TEXT, &editstream );
			w.SendMessage( editesi.hred, w.EM_SETMODIFY, false,0 );
		endif;
		
		ENDUSE;
	end setText;
		
	command_insert_time :procedure;
		// inserts time with formatted string at cursor
		var format :string;
			
	begin command_insert_time;
		mov( str.talloc(1000), format );
		if( !config.readString( s_settings, "Time Format", format )) then
			str.cpy( default_time_format, format ); 
		endif;

		w.GetTimeFormat(w.LOCALE_USER_DEFAULT,
						NULL,
						NULL,
						format,
						&buffer,
						@size(buffer));
		mov( window.buffer_focus, eax );
		w.SendMessage( editeax.hred, w.EM_REPLACESEL, true, &buffer );		
	end command_insert_time;

	command_insert_date :procedure;
		// inserts date with formatted string at cursor
		var format :string;
			
	begin command_insert_date;
		mov( str.talloc(1000), format );
		if( !config.readString( s_settings, "Date Format", format )) then
			str.cpy( default_date_format, format ); 
		endif;
				
		w.GetDateFormat(w.LOCALE_USER_DEFAULT,
						NULL,
						NULL,
						format,
						&buffer,
						@size(buffer));
		mov( window.buffer_focus, eax );
		w.SendMessage( editeax.hred, w.EM_REPLACESEL, true, &buffer );
	end command_insert_date;
	
	command_insert_date_time :procedure;
	
		// inserts date/time at cursor

	begin command_insert_date_time;
	
		command_insert_date();
		command_insert_time();
	
	end command_insert_date_time;
	
	JumpLog :procedure 
		
		// inserts the date/time in the editor
		// either at the top of the file, or appends to the bottem
		// direction is determined in al
		
		{@noframe};
	begin JumpLog;
		USE( ESI );
		
		mov( window.buffer_focus, esi );
		if (al='<') then	// append at top
			w.SendMessage( editesi.hred,w.EM_SETSEL, 5, 5 );
			
		else				// append at bottom
			w.SendMessage( editesi.hred, w.EM_SETSEL,-1,-1 );
		endif;
		w.SendMessage( editesi.hred, w.EM_REPLACESEL,true, s_nl );
		command_insert_date_time();
		w.SendMessage( editesi.hred, w.EM_REPLACESEL,true, s_nl );
		
		ENDUSE;
		ret();
	end JumpLog;

	Cmd_File_Quit :procedure( hwin:dword; wparam:dword; lparam:dword );
	begin Cmd_File_Quit;
		
		w.SendMessage (hwin, w.WM_CLOSE, 0, 0 );
		
	end Cmd_File_Quit;

	checkLog :procedure{ @noframe };

		// looks at the top of the file to determine is
		// the user desires logging
		// looks for .LOG message on top of loaded file.
		// optionally, there may be a direction determined by
		// '<' this is loaded into al and control passed to JumpLog();

	begin checkLog;
		//dbg.put ("CheckLog");
		USE( ESI );
		
		mov( 0, find_range.chrg.cpMin );
		mov( 5, find_range.chrg.cpMax );
		mov( &buffer,find_range.lpstrText );
		mov( window.buffer_focus, esi );
		w.SendMessage( editesi.hred, w.EM_GETTEXTRANGE, 0, &find_range);
		mov(&buffer,esi);
		lodsd();
		if ( eax = $474f4c2e ) then	// .LOG
			// check direction
			lodsb();
			JumpLog();
			w.SendMessage( editesi.hred, w.EM_SETMODIFY, false, 0 );
		endif;
		
		ENDUSE;
		ret();
	end checkLog;

	GetSelText :procedure( lpBuff:dword );
	
		// gets the selected text range for use
		// with find
	
	begin GetSelText;
		USE( ESI );
		
		mov( lpBuff, eax );
		mov( eax, find_range.lpstrText );
		mov( window.buffer_focus, esi );
		w.SendMessage( editesi.hred, w.EM_EXGETSEL,0, &find_range.chrg );
		mov( find_range.chrg.cpMax,eax );
		sub( find_range.chrg.cpMin,eax );
		if( eax >= @elements( findbuf ) ) then
			mov( @elements( findbuf) -1, find_range.chrg.cpMax );
		endif;
		
		w.SendMessage( editesi.hred, w.EM_GETTEXTRANGE,0,&find_range );
		
		ENDUSE;
	end GetSelText;
	
	AboutDlgProc :procedure( lParam:dword; wParam:dword; uMsg:uns32; hDlg:dword);
	
		// opens a window to display version number
	
	begin AboutDlgProc;
		
		if (uMsg = w.WM_INITDIALOG) then
			mov( hDlg, window.habout );
			w.SetDlgItemText( window.habout,ID_ABOUTGRP,version ); 
			w.SetFocus( window.habout );

		elseif( uMsg = w.WM_COMMAND ) then
			 if( wParam = w.IDOK || wParam= w.IDCANCEL ) then				

			 	w.SendMessage( hDlg, w.WM_CLOSE, NULL, NULL );

			 endif;
		elseif( uMsg = w.WM_CLOSE ) then

			w.DestroyWindow( window.habout );
			mov( 0, window.habout );
			mov( window.buffer_focus, eax );
			w.SetFocus( editeax.hred );
		
		else
			mov( false, eax );
			exit AboutDlgProc;
		endif;
	
		mov( true, eax );	
		
	end AboutDlgProc;

	AddMenus :procedure;
		
		// initializes menus
		
		storage
			file_menu 		:dword;
			edit_menu 		:dword;
			options_menu 	:dword;
			view_menu 		:dword;
			help_menu		:dword;
			recent_menu 	:dword;
			line_break_menu	:dword;
			date_time_menu	:dword;
			build_str		:string;
			
	begin AddMenus;
		
		mov( str.talloc( 1000 ), build_str );
		
		// create all the menu handles here
		mov( w.CreateMenu(), file_menu);
		mov( w.CreateMenu(), edit_menu);
		mov( w.CreateMenu(), options_menu);
		mov( w.CreateMenu(), view_menu);
		mov( w.CreateMenu(), help_menu);
		mov( w.CreatePopupMenu(), recent_menu );
		mov( w.CreatePopupMenu(), date_time_menu );
		mov( w.CreatePopupMenu(), line_break_menu );
		
		//
		//	File Menu
		//
		
		w.AppendMenu( file_menu, w.MF_STRING, IDM_NEW, "&New	Ctrl+N");
		w.AppendMenu( file_menu, w.MF_STRING, IDM_OPEN, "&Open	Ctrl+O");
		w.AppendMenu( file_menu, w.MF_STRING, IDM_INST, "New &Window	Shift+Ctrl+N");
		w.AppendMenu( file_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( file_menu, w.MF_STRING, IDM_SAVE, "&Save	Ctrl+S");
		w.AppendMenu( file_menu, w.MF_STRING, IDM_SAVEAS, "Save &As...	Shift+Ctrl+S");
		w.AppendMenu( file_menu, w.MF_STRING, IDM_SAVE_SELECTION_AS, "Save Se&lection As...");
		w.AppendMenu( file_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( file_menu, w.MF_STRING, IDM_RECENT, "Recent Files");
		w.AppendMenu( file_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( file_menu, w.MF_STRING, IDM_QUIT, "&Quit	ESC");
		w.AppendMenu( window.hmenu, w.MF_POPUP, file_menu, "&File");

		//
		//	Edit Menu
		//
	
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_UNDO, "&Undo	Ctrl+Z");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_REDO, "&Redo	Ctrl+Y");
		w.AppendMenu( edit_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_CUT, "&Cut	Ctrl+X");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_COPY, "C&opy	Ctrl+C");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_PASTE, "&Paste	Ctrl+V");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_SELECTALL, "Select &All	Ctrl+A");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_COPY_WORD, "Copy Word	Shift+Ctrl+W");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_DELETE_WORD, "Delete Word	Ctrl+W");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_KILL_LINE, "Kill Line	Ctrl+\");
		w.AppendMenu( edit_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_TO_UPPER, "To Upper Case	Ctrl+U");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_TO_LOWER, "To Lower Case	Shift+Ctrl+U");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_INCREASE_INDENT, "Increase Line Indent	Shift+Tab");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_DECREASE_INDENT, "Decrease Line Indent	Shift+Ctrl+Tab");
		w.AppendMenu( edit_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_FIND, "&Find / Replace	Ctrl+F");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_FINDNEXT, "Find &Next	F3");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_FINDPREV, "Find &Previous	Ctrl+F3");
		w.AppendMenu( edit_menu, w.MF_STRING, IDM_EDIT_GOTO, "&Goto Line	Ctrl+G");
		w.AppendMenu( edit_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( edit_menu, w.MF_STRING | w.MF_POPUP, date_time_menu, "Date/Time" );
			w.AppendMenu( date_time_menu, w.MF_STRING, IDM_DATE_TIME, "&Insert Date/Time	F5");
			w.AppendMenu( date_time_menu, w.MF_STRING, IDM_DATE, "Insert &Date	Shift+F5");
			w.AppendMenu( date_time_menu, w.MF_STRING, IDM_TIME, "Insert &Time	Ctrl+F5");
			w.AppendMenu( date_time_menu, w.MF_STRING, IDM_DATE_FORMAT, "Set Date Format...");
			w.AppendMenu( date_time_menu, w.MF_STRING, IDM_TIME_FORMAT, "Set Time Format...");
		w.AppendMenu( window.hmenu, w.MF_POPUP, edit_menu, "&Edit");

		//
		//	Options Menu
		//

		w.AppendMenu( options_menu, w.MF_STRING, IDM_FONT, "&Font...");
		w.AppendMenu( options_menu, w.MF_STRING, IDM_FOREGROUND, "&Foreground Color...");
		w.AppendMenu( options_menu, w.MF_STRING, IDM_BACKGROUND, "&Background Color...");
		w.AppendMenu( options_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( options_menu, w.MF_STRING, IDM_AUTO, "&Autosave	F2");
		w.AppendMenu( options_menu, w.MF_STRING, IDM_READONLY, "&Read Only	F6");
		w.AppendMenu( options_menu, w.MF_STRING, IDM_SETTAB, "&Set Tabs...");
		w.AppendMenu( options_menu, w.MF_STRING, IDM_TAB_AS_SPACE, "Tabs As &Spaces");
		w.AppendMenu( options_menu, w.MF_STRING, IDM_AUTOINDENT, "Auto &Indent");
		w.AppendMenu( options_menu, w.MF_STRING | w.MF_POPUP, recent_menu, "Recent File Options");
			w.AppendMenu( recent_menu, w.MF_STRING, IDM_RECENTNEW, "Open in New Window");
			w.AppendMenu( recent_menu, w.MF_STRING, IDM_CLEAREXIT, "Clear History on Exit");
			w.AppendMenu( recent_menu, w.MF_STRING, IDM_OPENRECENT, "Open Most Recent");
			w.AppendMenu( recent_menu, w.MF_STRING, IDM_REMEMBERPOS, "Remember Position");
		w.AppendMenu( options_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( options_menu, w.MF_STRING, IDM_ACTIVE_URL, "Active URLs");
		w.AppendMenu( options_menu, w.MF_STRING | w.MF_POPUP, line_break_menu, "Line Break");
			w.AppendMenu( line_break_menu, w.MF_STRING, IDM_CRLF, "CRLF");
			w.AppendMenu( line_break_menu, w.MF_STRING, IDM_LF, "LF");
		w.AppendMenu( options_menu, w.MF_STRING, IDM_DEFAULT_EXT, "Set Default Extension...");
		w.AppendMenu( options_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu( options_menu, w.MF_STRING, IDM_EDITINI, "Edit &Options");
		w.AppendMenu( window.hmenu, w.MF_POPUP, options_menu, "&Options");

		//
		//	View Menu
		//

		w.AppendMenu( view_menu, w.MF_STRING, IDM_PEG, "&Stay on Top	Ctrl+T");
		w.AppendMenu( view_menu, w.MF_STRING, IDM_WRAP, "&Word Wrap	F4");
		w.AppendMenu( view_menu, w.MF_STRING, IDM_VIEW_STATUS, "&Status Bar");
		w.AppendMenu( window.hmenu, w.MF_POPUP, view_menu, "&View");

		//
		//	Help Menu
		//

		w.AppendMenu( help_menu, w.MF_STRING, IDM_ABOUT, "&About...");
		w.AppendMenu( help_menu, w.MF_STRING, IDM_DOCUMENTS, "&Documents");
		w.AppendMenu( window.hmenu, w.MF_POPUP, help_menu, "&Help");

		w.SetMenu(window.hwnd, window.hmenu);

	end AddMenus;


	Msg_OpenDroppedFile :procedure( hwnd:dword; wParam:dword; lParam:dword );

		// handles opening dropped files
		var
			build_str	:string;
			

	begin Msg_OpenDroppedFile;
		mov( str.talloc( 1000 ), build_str );		
		pushabi;
		w.SetForegroundWindow( window.hwnd );
		
		mov( window.buffer_focus, esi );
		w.SetFocus( editesi.hred );
	
		getConfirm();
		if( !eax ) then	
			w.SetWindowText( editesi.hred, 0 );		// clear edit window
			w.DragQueryFile( wParam, 0, &buffer, @size(buffer) );
			w.GetLongPathName( &buffer, &buffer, @size(buffer) );
			str.cpyz( &buffer, build_str );
			loadFile( build_str );
			
		endif;
		popabi;
		xor( eax, eax );
		
	end Msg_OpenDroppedFile;


	Msg_Context :procedure( hwnd:dword; wParam:dword; lParam:dword );
		
		// right click context menu
		// opens edit menu
		
		var
			pt	:w.POINT;
		
	begin Msg_Context;
		USE( EBX );
		mov (lParam, eax);
		if (eax = -1) then
			w.GetCaretPos (pt);
			w.GetFocus();
			mov (eax, edx);
			w.ClientToScreen (edx, pt);
		else
			and ($ffff, eax);
			mov (eax, pt.x);
			mov (lParam, eax);
			shr (16, eax);
			mov (eax, pt.y);
		endif;
		
		mov( wParam, eax );
		mov( window.buffer_focus, ebx );
		if( eax = editebx.hred ) then
			w.GetMenu( hwnd );
			w.GetSubMenu( eax, 1 );	// edit menu, 2nd item
			w.TrackPopupMenu( eax, w.TPM_LEFTALIGN | w.TPM_RIGHTBUTTON, pt.x, pt.y, 0, hwnd, NULL );
		endif;
		
		ENDUSE;
		xor( eax, eax );
	end Msg_Context;

	setFont	:procedure;
		
		var
			cf		:w.CHARFORMAT2;
			modified	:dword;
			
	begin setFont;
		
		pushabi;
		mov( window.buffer_focus, esi );
		w.SendMessage( editesi.hred, w.EM_GETMODIFY, 0, 0 );
		mov( eax, modified );
		lea( eax, cf );
		mem2.fillMem( [eax], @size( cf ), 0 );
		mov( @size( cf ), cf.cbSize );
		mov( w.CFM_CHARSET | w.CFM_FACE | w.CFM_SIZE | w.CFM_COLOR, cf.dwMask );
		mov( logfont.lfCharSet, al );
		mov( al,cf.bCharSet );
		mov( logfont.lfPitchAndFamily, al );
		mov( al, cf.bPitchAndFamily );
		w.lstrcpyn( cf.szFaceName, &logfont.lfFaceName, w.LF_FACESIZE );
		mov( logfont.lfHeight, eax );
		neg( eax );
		mov( 15,ecx );
		mul( ecx );
		mov( eax, cf.yHeight );
		push( window.textColor );
		pop( cf.crTextColor );
		w.SendMessage( editesi.hred, w.WM_SETFONT, window.hfont, true );
		lea( eax, cf );
		w.SendMessage( editesi.hred, w.EM_SETCHARFORMAT, w.SCF_ALL, eax );
		w.SendMessage( editesi.hred, w.EM_SETMODIFY, modified, 0 );
		setTabs();
		popabi;
		
	end setFont;
	
	setTabs	:procedure;
	begin setTabs;
	
		pushabi;
		w.GetDialogBaseUnits();
		movzx( ax, ecx );
		config.readUns( s_settings, s_tabs );
		mul( ecx );
		shr( 1, eax );
		//dbg.put("tab distance :", (type uns32 eax));
		//mov( inf, esi );
		mov( window.buffer_focus, esi );
		mov( eax, window.tabs );
		// this is typically 4*the desired tab spaces
		w.SendMessage(editesi.hred, w.EM_SETTABSTOPS, 1, &window.tabs );
		
		// fill the tabs as spaces string
		str.cpy( "", strtabs );
		if( ! config.readUns( s_settings, s_tabs )) then
			mov( DEFAULT_TAB_STOP, eax );
		endif;
		while( eax ) do
			str.cat( " ", strtabs );
			dec( eax ); 
		endwhile;
		dbg.put("strtabs :", strtabs );
		popabi;
		
	end setTabs;

	setFormat :procedure;
		
		// initializes a new edit buffer
		// call function to set background and foreground colors, font and margins
		// call function to set sets tab width
			
	begin setFormat;
		
		mov( window.buffer_focus, esi );
		w.SendMessage( editesi.hred, w.EM_EXLIMITTEXT, 0, -1 );
		
		setFont();
		w.SendMessage( editesi.hred, w.EM_SETBKGNDCOLOR, false, window.backColor);
		
		setTabs();
		w.SendMessage( editesi.hred, w.EM_SETMARGINS, w.EC_LEFTMARGIN | w.EC_RIGHTMARGIN, 5<<16 | 5 );
	end setFormat;
	
	//!NOTE( "now that we are using window.buffer_focus, do we really need to pass Edit_Node ?" )
	updateActiveURL :procedure; //!( var inf :Edit_Node);
	begin updateActiveURL;
		pushabi;
		//!mov( inf, ebx );
		mov( window.buffer_focus, ebx );
		if( config.readBool( s_settings, "Active URL" ) ) then
			w.SendMessage( editebx.hred, w.EM_AUTOURLDETECT, true, NULL);
			w.SendMessage( editebx.hred, w.EM_SETEVENTMASK, 0, w.ENM_SELCHANGE | w.ENM_MOUSEEVENTS | w.ENM_LINK );
		else
			w.SendMessage( editebx.hred, w.EM_AUTOURLDETECT, false, NULL);
			w.SendMessage( editebx.hred, w.EM_SETEVENTMASK, 0, w.ENM_SELCHANGE | w.ENM_MOUSEEVENTS );
		endif;
		setFormat();
		popabi;
	end updateActiveURL;
	
	Msg_Create :procedure( hwin:dword; wParam:dword; lparam:dword );
	
		// create the main window
		// read settings from config to determine positions
		// update menus based on configuration settings
		// looks for command line passed arguments to open existing file
		// or start new file.
		var
			edit_style	:dword;
			build_str	:string;
		
	begin Msg_Create;
		pushabi;
		
		TODO( "this should create a new Edit_Node object and add it to the list" )
		TODO( "i changed my mind, this should probalby be done in main begin section instead." )
		mov( str.talloc( 1000 ), build_str );
		mov( hwin, eax );
		mov( eax, window.hwnd );
		w.CreateMenu();
		mov( eax, window.hmenu );
		w.SetMenu( window.hwnd, window.hmenu );
		AddMenus();
		w.GetSubMenu( window.hmenu, 1 );
		mov( eax, window.hcontextmenu );
		w.DragAcceptFiles( window.hwnd, true );

		w.CreateStatusWindow( w.WS_CHILD, NULL, window.hwnd, IDC_SBAR );
		mov( eax, window.hstatus );
		w.SendMessage( eax, w.SB_SETPARTS, STATUS_PARTS, &statusParts );


		mov( 	w.ES_AUTOVSCROLL | w.ES_LEFT | w.ES_MULTILINE |
				w.ES_NOHIDESEL | w.ES_WANTRETURN |
				w.WS_CHILD | w.WS_CLIPSIBLINGS | w.WS_HSCROLL | w.ES_AUTOHSCROLL |
				w.WS_VSCROLL | w.WS_VISIBLE,
				edit_style );
					
		if( config.readBool( s_settings, s_readonly )) then
			or( w.ES_READONLY, edit_style );
		endif;
		// create edit window
		w.CreateWindowEx( w.WS_EX_CLIENTEDGE, s_resedClass, NULL,
					edit_style, 0, 0, 0, 0, window.hwnd,
					window.hcontextmenu, window.hinst, NULL );
		mov( window.buffer_focus, esi );
		mov( eax, editesi.hred );
				
		// subclass the edit control
		w.SetWindowLong( editesi.hred, w.GWL_WNDPROC, &Proc_Edit );
		mov( eax, editesi.old_proc);
		
		updateActiveURL(); //!( info );
		w.SetFocus( editesi.hred );

		// check for a filename passed as an argument and try to open that file.
		// if file doesn't exist, start new document with that filename.
		arg.c();
		if( eax > 1 ) then
			
			// get an argument, see if it is a file that exists,
			// if so, open it.
			
			arg.v( 1 );
			w.GetLongPathName( eax, &buffer, @size(buffer) -1 );
			if (eax) then
				
				// file path copied, try to open it.
				
				str.cpyz( &buffer, build_str );
				loadFile( build_str );
				if (eax) then
					if( config.readBool( s_settings, s_rememberpos )) then
						config.readUns( s_settings, "Start Position");
						//lea( edi, editesi.cursor );
						mov( eax, info.cursor.start_index );
						mov( eax, info.cursor.end_index );
						//mov( eax, charrangeedi.start_index );
						//mov( eax, charrangeedi.end_index );
						w.SendMessage( info.hred, w.EM_EXSETSEL, 0, &info.cursor );
					endif;
					jmp skipOpenRecent;
				endif;
			else
				
				// there is no file, create a new document with name passed on command line
				
				// this old way was not working if user enters a file path instead of just a file name.
				//filesys.gwd( info.filepath );
				//str.cat ("\", info.filepath);
				//arg.v(1);
				//str.catz (eax, info.filepath);
				
				arg.v(1);
				str.cpyz (eax, editesi.filepath); 
				jmp skipOpenRecent;
			endif;
		endif;
		
		// no file requested as an argument,
		// check config to see if we want to open the most recent document
		
		if( config.readBool( s_settings, s_openrecent ) ) then
			
			// we want to open the most recent file. do we have a recent file to open?
			
			if( config.isSectionDefined( s_recent )) then
				
				config.readItem( s_recent, 0, build_str );
				loadFile( build_str );
				if( ! eax ) then
					
					// the file we want to open doesn't exit anymore. remove it from our list.
					config.deleteItem( s_recent, 0 );

				endif;
				
				// do we want to move the cursor to the position it was when the file was closed?
				
				if( config.readBool( s_settings, s_rememberpos )) then
					config.readUns( s_settings, "Start Position");
					mov( eax, info.cursor.start_index );
					mov( eax, info.cursor.end_index );
					w.SendMessage( info.hred, w.EM_EXSETSEL, 0, &info.cursor );
				endif;
				
			endif;
			
		endif;
		skipOpenRecent:
		getInfo();
		updateMenu();
		updateStatus();
		
		popabi;
		xor( eax, eax );
	end Msg_Create;

	Msg_Notify :procedure( hwin:dword; wparam:dword; lparam:dword );
		var
		//	txt	:w.TEXTMETRIC;
		//	hdc	:dword;
			text_range	:w.TEXTRANGE;
			
	begin Msg_Notify;

		mov( lparam, edx );
		mov( (type w.NMHDR[EDX]).code, eax );
		mov( window.buffer_focus, ebx );
			
		if( eax = w.EN_SELCHANGE ) then	
		//	dbg.put("selchange");
		//	mov( logfont.lfHeight, eax );
		//	neg( eax );
		//	dbg.put( "height:", (type uns32 eax ));
		//	w.CreateCaret( info.hred, NULL, 1 , eax );
		//	w.ShowCaret( info.hred );
		//	w.GetDC( info.hred );
		//	mov( eax, hdc );
		//	mov((type dword 0), buffer[0]);
		//	w.GetCharWidth32( hdc, w.VK_W, w.VK_X, &buffer );
		//	dbg.put("width :", (type uns32 buffer[0]) );
		//	dbg.separator;
		//	dbg.dumpmem( &buffer, 16 );
		//	w.GetTextMetrics( hdc, txt );
		//	dbg.separator;
		//	dbg.put("max char width :", txt.tmMaxCharWidth );
		//	dbg.put("avg char width :", txt.tmAveCharWidth );
		//	w.ReleaseDC( info.hred, hdc );
			
			updateStatus();
		
		elseif( eax = w.EN_LINK ) then
			if( (type w.ENLINK[edx]).msg = w.WM_LBUTTONDOWN ) then
				mov( &buffer, text_range.lpstrText );
				mov( (type w.ENLINK[edx]).chrg.cpMin, text_range.chrg.cpMin );
				mov( (type w.ENLINK[edx]).chrg.cpMax, text_range.chrg.cpMax );
				lea( eax, text_range );
				w.SendMessage( editebx.hred, w.EM_GETTEXTRANGE, 0, eax );
				w.ShellExecute( NULL, NULL, &buffer, NULL, NULL, 1 );  

			endif;
		
		elseif( eax = w.EN_MSGFILTER ) then
			if( (type w.MSGFILTER[EDX]).msg = w.WM_LBUTTONDOWN ) then
				
				mov( shift_down, dl );
				if( editebx.mark ) then
					mov( true, shift_down );
				else
					mov( false, shift_down );
				endif;
				xor( eax, eax ); // clear ctrl_down
				clear_keystate();
				mov( dl, shift_down );
				updateStatus();
				
			endif;
		
		endif;
		
		xor( eax, eax );

	end Msg_Notify;
	
	newInstance :procedure( filename:string );
		
		// opens a new instance of SavageEd
		
		var
			s	:string;
			
	
	begin newInstance;
		dbg.put("newInstance" );
		
		move( str.talloc( 300 ), s );
		add( 20,window.xPos );
		config.writeUns( s_window, "xPos",window.xPos );
		add( 20,window.yPos );
		config.writeUns( s_window, "yPos",window.yPos );
		config.writeUns( s_window, "width",window.width);
		config.writeUns( s_window, "height",window.height);
		
		getConfigPath( s );
		config.writeFileName( s );
		
		w.GetModuleFileName( NULL, &buffer, @size(buffer) );
		str.cpyz( &buffer, s );
		if( filename != NULL ) then
			str.put2( s, ' ', filename );
		endif;
		os.bkgnd( s );
		
	end newInstance;

	openRecent :procedure(id:dword);
	
		// opens a recent file
		// may start a new instance, based on user options
		
		var
			s	:string;
			
	begin openRecent;
		//dbg.put("openRecent" );
		move( str.talloc( 300 ), s );
		getConfirm();
		if (! eax) then
			w.GetMenu( window.hwnd );
			w.GetMenuStringA( eax, id, buffer, @elements( buffer ), w.MF_BYCOMMAND );
			str.cpyz( &buffer, s );
			
			if( config.readBool( s_settings, s_recentnew )) then
				
				newInstance( s );
				
			else
				
				loadFile( s );
				if( ! eax ) then
					config.findItem( s_recent, s );
					config.deleteItem( s_recent, eax );
					updateMenu();
				endif;
				
			endif;
			
		endif;
	
	end openRecent;

	updateRecentLog :procedure {@noframe};
	
		// update the recent log and menu
	
	begin updateRecentLog;
		dbg.put("updateRecentLog");
		mov( window.buffer_focus, ebx );
		if( config.findItem ( s_recent, editebx.filepath ) <> -1 ) then
			
			config.deleteItem ("Recent Files", eax);
			
		endif;
		
		config.insertItem( s_recent, 0, editebx.filepath );
		
		if( config.getItemCount( s_recent ) > 20) then
			
			config.deleteItem( s_recent, 20 );
			
		endif;
		updateMenu();
		ret();
	end updateRecentLog;

	Proc_Input :procedure( lParam:dword; wParam:dword; uMsg:uns32; hWin:dword );
	
		// opens a text box to get text input
	
	begin Proc_Input;
		pushabi;
		
		mov( uMsg, eax );
		
		if( eax = w.WM_COMMAND ) then
	
			mov( wParam, eax );
			mov( eax, edx );
			shr( 16, edx );
			and( $0ffff, eax );
			if( edx = w.BN_CLICKED ) then
				
				if( eax = w.IDOK ) then
					
					w.GetDlgItemTextA( hWin, IDC_EDT_INPUT, buffer, @size(buffer) );
					str.cpyz( &buffer, input.return );
					mov( input.return, return );
					
					w.SendMessage( hWin, w.WM_DESTROY, 0, 0 );
					
				elseif( eax = w.IDCANCEL ) then
					
					mov( 0, return );
					w.SendMessage( hWin, w.WM_DESTROY, 0, 0 );
					
				endif;
				
			endif;
	
		elseif( eax = w.WM_CLOSE ) then
			
			w.SendMessage( hWin, w.WM_DESTROY, 0, 0 );
		
		elseif( eax = w.WM_DESTROY ) then
			
			w.EndDialog( hWin, return );
			
		elseif( eax = w.WM_INITDIALOG ) then
			
			str.cpy( s_empty, input.return );
			if( lParam ) then
				w.SetWindowText( hWin, lParam );
			endif;
			
			w.GetDlgItem( hWin, IDC_EDT_INPUT );
			mov( eax, edx );
			if( str.length( input.initial) > 0 ) then
				w.SetWindowText( edx, input.initial );
			endif;
			w.SetFocus( edx );
			
		endif;
		
		xor( eax, eax );
		popabi;
	end Proc_Input;
		
end Window_unit;
